<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>C00lGUI</title>
<style>
:root{
  --bg:#050405;
  --card-grad-top: rgba(255,255,255,0.02);
  --card-grad-bottom: rgba(255,255,255,0.01);
  --red:#ff3b3b;
  --accent:#ff6b6b;
  --red-deep:#b71c1c;
  --muted:rgba(255,255,255,0.92);
  --mono: "Courier New", Courier, monospace;
  --zap-color: rgba(88, 142, 255, 0.95);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:radial-gradient(ellipse at center,#0f0f12 0%, #020202 60%),linear-gradient(180deg,#060003 0%, #000 100%);color:var(--muted);font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;}
.wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:28px;}
.card{width:1060px;max-width:96%;background:linear-gradient(180deg,var(--card-grad-top),var(--card-grad-bottom));border-radius:12px;padding:28px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 30px 90px rgba(0,0,0,0.6);text-align:center;}
.title{font-size:34px;color:var(--red);font-weight:900;margin-bottom:6px;text-shadow:0 0 18px rgba(255,80,80,0.12);}
.enable{display:inline-block;padding:12px 18px;border-radius:10px;background:transparent;border:1px solid rgba(255,255,255,0.03);cursor:pointer;}
.kbd{background:rgba(255,255,255,0.03);padding:3px 8px;border-radius:6px;font-family:var(--mono);font-size:13px;color:var(--muted);}
#fakeCMD{display:none;position:fixed;top:6vh;left:6vw;width:88vw;height:88vh;max-width:1280px;max-height:920px;background:#070404;border:3px solid var(--red-deep);border-radius:10px;z-index:99999;overflow:hidden;color:var(--red);font-family:var(--mono);box-shadow:0 40px 160px rgba(183,28,28,0.35);}
#cmdHeader{display:flex;align-items:center;gap:12px;padding:12px 16px;background:linear-gradient(90deg, rgba(255,0,0,0.02), rgba(255,0,0,0.01));border-bottom:1px solid rgba(255,0,0,0.04);}
#cmdTitle{font-weight:900;color:var(--red-deep)}#cmdClose{margin-left:auto;background:transparent;border:none;color:var(--red);cursor:pointer;padding:8px 12px;border-radius:6px}#cmdClose:hover{background:rgba(255,0,0,0.03)}
#cmdBody{padding:16px;height:calc(100% - 128px);overflow:auto;white-space:pre-wrap;font-size:14px;line-height:1.45;background: linear-gradient(180deg,#040303 0%, #000 100%);scrollbar-color:#ff6b6b #070404;}
#cmdInputWrap{padding:10px 16px 18px 16px;border-top:1px solid rgba(255,0,0,0.03);display:flex;gap:8px;align-items:center;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));}
#cmdPrompt{color:var(--red);font-family:var(--mono);font-size:14px}#cmdInput{flex:1;background:transparent;border:none;outline:none;color:var(--red);font-family:var(--mono);font-size:14px}
.visual-wrap{margin:12px 0;display:flex;justify-content:center;align-items:center;} .visual-wrap svg{width:88%;max-width:920px;height:auto;display:block;background:#020202;border-radius:6px;border:1px solid rgba(255,255,255,0.02);}
.cmd-line{margin:6px 0;font-family:var(--mono);color:var(--red);} .cmd-echo{font-weight:600;color:var(--red);} .cmd-strong{font-weight:800;color:var(--red);} .accessDenied{display:block;margin-top:8px;font-weight:900;font-size:34px;color:#ff4d4d;text-shadow:0 0 18px rgba(255,0,0,0.18);letter-spacing:2px;}
.cmd-alert{font-weight:900;font-size:20px;color:#ff4d4d;text-shadow:0 0 8px rgba(255,0,0,0.18);margin-top:8px;animation:glitchFlash 80ms steps(2,end) 0s 12;display:inline-block;padding:6px 8px;border-radius:6px;background: rgba(255,0,0,0.02);} @keyframes glitchFlash {0%{opacity:0.05;transform:translateX(0);}10%{opacity:0.95;transform:translateX(-2px);}20%{opacity:0.2;transform:translateX(1px);}30%{opacity:0.95;transform:translateX(0);}40%{opacity:0.1;transform:translateX(-1px);}50%{opacity:0.95;transform:translateX(2px);}60%{opacity:0.05;transform:translateX(0);}100%{opacity:0.95;transform:translateX(0);}}

/* zap effect around element */
.zap-ring {
  position: absolute;
  pointer-events: none;
  border-radius: 50%;
  box-shadow: 0 0 16px 4px rgba(120,160,255,0.9), 0 0 40px 12px rgba(88,142,255,0.45), 0 0 120px 28px rgba(88,142,255,0.12);
  transform: translate(-50%,-50%) scale(0.2);
  opacity: 1;
  transition: transform 260ms cubic-bezier(.2,.9,.3,1), opacity 340ms ease;
  mix-blend-mode: screen;
}

/* responsive */
@media (max-width:720px){.card{padding:20px;}#fakeCMD{top:3vh;left:2vw;width:96vw;height:94vh;}}
</style>
</head>
<body>
<div class="wrap">
  <div class="card" role="main" aria-live="polite">
    <div class="title">WELCOME BACK,007n7</div>
    <div class="sub"></div>
    <div class="enable" id="enableText"><div style="font-weight:700">Enable terminal..</div></div>
  </div>
</div>

<div id="fakeCMD" role="dialog" aria-modal="true" aria-label="C00lKID Terminal">
  <div id="cmdHeader">
    <div id="cmdTitle">C00lGUI</div>
    <div style="font-size:12px;color:rgba(255,255,255,0.12)">hack mode</div>
    <button id="cmdClose" aria-label="Close terminal">CLOSE</button>
  </div>
  <div id="cmdBody" tabindex="0" aria-live="polite"></div>
  <div id="cmdInputWrap"><div id="cmdPrompt">&gt;</div><input id="cmdInput" autocomplete="off" spellcheck="false" aria-label="Terminal input" /></div>
</div>

<script>
/*
  C00lGUI full script
  - teleport('object') added (random destination within SVG/viewBox)
  - go to('link') opens link in a new tab
  - startup/init runs once per browser (localStorage flag)
  - zap effect (visual) + zap sound (WebAudio)
  - keep command names consistent with function-call syntax
*/

/* -------------------------
   DOM references & state
   ------------------------- */
const enableText = document.getElementById('enableText');
const fakeCMD = document.getElementById('fakeCMD');
const cmdBody = document.getElementById('cmdBody');
const cmdInput = document.getElementById('cmdInput');
const cmdClose = document.getElementById('cmdClose');

let terminalReady = false;
let startupRan = false;
let alertScheduled = false;
let firewallBroken = false;
let runningHack = false;
let hackInterval = null;
let hackSucceeded = false;
let targetPassword = '';
let listenDone = false;
let svgContainer = null;
let cloneLayer = null;
let cloneObjects = [];
let clonesActive = false;
let animationStopped = false;
let CLONE_COUNT = 6;
let CLONE_DURATION = 5000;
let CLONE_SPEED = 3.0;
let currentInjectMode = 'random';
let lastCursorPos = { x:120, y:40 };
let warpContainer = null;

/* -------------------------
   Audio (WebAudio zap + boom)
   ------------------------- */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){ if(audioCtx) return audioCtx = new AudioCtx(); return audioCtx; }
function playZapSound(){
  try{
    const ctx = ensureAudio();
    const now = ctx.currentTime;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'sawtooth';
    o.frequency.setValueAtTime(880, now);
    o.frequency.exponentialRampToValueAtTime(1400, now + 0.08);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.25, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.16);
    o.connect(g); g.connect(ctx.destination);
    o.start(now); o.stop(now + 0.18);
  }catch(e){ /* audio blocked or unavailable */ }
}
function playBoomSound(){
  try{
    const ctx = ensureAudio();
    const now = ctx.currentTime;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'triangle';
    o.frequency.setValueAtTime(120, now);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.45, now + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
    o.connect(g); g.connect(ctx.destination);
    o.start(now); o.stop(now + 0.5);
  }catch(e){}
}

/* -------------------------
   helpers: append lines, escape
   ------------------------- */
function appendLine(text, cls){
  const el = document.createElement('div');
  el.className = cls ? 'cmd-line ' + cls : 'cmd-line';
  // remove colons as you asked earlier
  el.innerHTML = String(text).replace(/:/g,'');
  cmdBody.appendChild(el);
  cmdBody.scrollTop = cmdBody.scrollHeight;
}
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m]); }

/* -------------------------
   Startup / init once (localStorage)
   ------------------------- */
function checkStartupFlag(){
  try{
    const k = 'C00LGUI_init_done_v1';
    if(localStorage.getItem(k) === '1'){ startupRan = true; return false; }
    // set flag now so it doesn't run again next page load
    localStorage.setItem(k, '1');
    startupRan = true;
    return true;
  }catch(e){
    // if localStorage blocked, run once per session variable fallback
    if(window.__C00LGUI_init_ran) return false;
    window.__C00LGUI_init_ran = true;
    startupRan = true;
    return true;
  }
}

/* one-time startup visuals (only runs when checkStartupFlag true) */
function runStartupIfNeeded(){
  const shouldRun = checkStartupFlag();
  if(!shouldRun) return;
  // minimal startup lines
  appendLine('[C00lGUI] Initializing subsystems', 'cmd-echo');
  appendLine('Loading UI modules');
  appendLine('Applying security sandbox');
  appendLine('Initialization complete');
}

/* -------------------------
   Terminal show/hide & keybinding
   ------------------------- */
function ensureWarpContainer(){
  if(!warpContainer){
    warpContainer = document.createElement('div');
    warpContainer.style.position = 'fixed';
    warpContainer.style.left = '0';
    warpContainer.style.top = '0';
    warpContainer.style.width = '100%';
    warpContainer.style.height = '100%';
    warpContainer.style.pointerEvents = 'none';
    warpContainer.style.zIndex = 100000;
    document.body.appendChild(warpContainer);
  }
}
function showTerminal(){
  fakeCMD.style.display = 'block';
  cmdBody.innerHTML = '';
  appendLine('<span style="color:#ff7b7b">[C00lGUI]</span>', 'cmd-echo');
  runStartupIfNeeded();
  appendLine('Terminal ready');
  terminalReady = true;
  cmdInput.disabled = false;
  cmdInput.focus();
  scheduleOneTime30sAlert();
  ensureWarpContainer();
}
function hideTerminal(){
  fakeCMD.style.display = 'none';
  if(runningHack && hackInterval){ clearInterval(hackInterval); hackInterval = null; runningHack = false; }
}
window.addEventListener('keydown', function(e){
  if(e.ctrlKey && (e.key === 'r' || e.key === 'R')){
    e.preventDefault();
    showTerminal();
  }
  if(e.key === 'Escape'){
    if(fakeCMD.style.display === 'block'){
      e.preventDefault();
      hideTerminal();
    }
  }
});
cmdClose.addEventListener('click', hideTerminal);
enableText.addEventListener('click', showTerminal);

/* -------------------------
   One-time 30s alert (single display)
   ------------------------- */
function scheduleOneTime30sAlert(){
  if(alertScheduled) return;
  alertScheduled = true;
  setTimeout(()=>{
    const choices = ['C00lKID GOT ATTACKED','THE HOUSE GOT DESTROYED C00lKID IN DANGER!!!'];
    const pick = choices[Math.random() < 0.5 ? 0 : 1];
    const alertDiv = document.createElement('div');
    alertDiv.className = 'cmd-line cmd-alert';
    alertDiv.textContent = pick;
    cmdBody.appendChild(alertDiv);
    cmdBody.scrollTop = cmdBody.scrollHeight;
    fakeCMD.style.border = '3px solid #ff0000';
    setTimeout(()=>{ fakeCMD.style.border = '3px solid var(--red-deep)'; }, 1200);
    playBoomSound();
  }, 30000);
}

/* -------------------------
   Noisy samples for hack
   ------------------------- */
const noiseSamples = [
  "Loading kernel module... OK",
  "Resolving vector signature 0x" + Math.floor(Math.random()*0xFFFF).toString(16),
  "Spawning rogue thread at 0x" + Math.floor(Math.random()*0xFFFF).toString(16),
  "Buffering entropy... 32%",
  "Hash collision detected retrying",
  "Allocating virtual page " + Math.floor(Math.random()*4096),
  "Patching syscall table done",
  "Overflowing stack frame warning",
  "Decrypting payload chunk 3/8",
  "Handshake with unknown host established",
  "Randomizing pointers OK",
  "Clearing temp logs",
  "Flushing CPU cache lines",
  "Injecting packet to /dev/null",
  "Kernel panic simulated testmode",
  "Synchronizing time server fail",
  "Forking zombie processes 7",
  "Simulating memory leak +1.2MB"
];

/* -------------------------
   Commands implementation
   ------------------------- */
function cmd_firewall(){
  if(firewallBroken){ appendLine('Firewall breaker already active'); return; }
  appendLine('> Engaging firewall breaker', 'cmd-echo');
  appendLine('Loading bypass modules');
  setTimeout(()=>{ firewallBroken = true; appendLine('Firewall bypass engaged'); }, 650);
}

let usedPasswords = new Set();
function genPassword(len){ len = len || 12; const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; for(let t=0;t<5000;t++){ let s=''; for(let i=0;i<len;i++) s += chars.charAt(Math.floor(Math.random()*chars.length)); if(!usedPasswords.has(s)){ usedPasswords.add(s); return s; } } let fb=''; for(let i=0;i<len;i++) fb += chars.charAt(Math.floor(Math.random()*chars.length)); usedPasswords.add(fb); return fb; }

function cmd_hack(){
  if(runningHack){ appendLine('Hack already running'); return; }
  appendLine('> Executing hack sequence', 'cmd-echo');
  runningHack = true;
  let ticks = 0;
  const maxTicks = 25;
  hackInterval = setInterval(()=>{
    const lines = 1 + Math.floor(Math.random()*2);
    for(let i=0;i<lines;i++){
      const idx = Math.floor(Math.random()*noiseSamples.length);
      const text = noiseSamples[idx].replace(/\d+/g, ()=>Math.floor(Math.random()*9999));
      appendLine(text);
    }
    ticks++;
    if(ticks >= maxTicks){
      clearInterval(hackInterval); hackInterval = null; runningHack = false;
      if(!firewallBroken){
        appendLine('');
        appendLine('<span class="accessDenied">ACCESS DENIED</span>');
        playZapSound();
      } else {
        targetPassword = genPassword(12);
        appendLine('');
        appendLine('<span class="cmd-strong">target password ' + targetPassword + '</span>');
        hackSucceeded = true;
        appendLine('(run listen next to visualize network; control after listen)');
        playZapSound();
      }
    }
  }, 200);
}

/* LISTEN -> create SVG visualization (computer -> globe -> target) */
function cmd_listen(){
  if(!hackSucceeded){ appendLine('Listen denied — run hack successfully first'); return; }
  if(listenDone){ appendLine('Listen already executed'); return; }
  appendLine('> Listening for endpoints', 'cmd-echo');
  const steps = ['Probing network','Collecting ARP','Scanning ports','Resolving DNS','Fetching routes','Enumerating hosts'];
  let s = 0; const si = setInterval(()=>{
    appendLine(steps[Math.floor(Math.random()*steps.length)] + ' ' + Math.floor(Math.random()*120));
    s++;
    if(s >= 10){ clearInterval(si); createNetworkVisual(); listenDone = true; appendLine(''); appendLine('(listen complete — control available)'); }
  }, 220);
}

function createNetworkVisual(){
  const prev = document.querySelector('.visual-wrap');
  if(prev && prev.parentNode) try{ prev.parentNode.removeChild(prev); }catch(e){}
  const wrap = document.createElement('div');
  wrap.className = 'visual-wrap';
  const svgns = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgns,'svg');
  svg.setAttribute('viewBox','0 0 240 80');
  svg.setAttribute('preserveAspectRatio','xMidYMid meet');

  // path & defs
  const defs = document.createElementNS(svgns,'defs');
  const path = document.createElementNS(svgns,'path');
  const pid = 'path_' + Date.now();
  path.setAttribute('id', pid);
  path.setAttribute('d', 'M36,24 C80,24 128,36 156,36 C184,36 212,24 212,24');
  path.setAttribute('fill','none');
  defs.appendChild(path);
  svg.appendChild(defs);

  // visible dashed path
  const visPath = document.createElementNS(svgns,'path');
  visPath.setAttribute('d', path.getAttribute('d'));
  visPath.setAttribute('stroke', '#ff6b6b');
  visPath.setAttribute('stroke-width','1.4');
  visPath.setAttribute('stroke-dasharray','6 6');
  visPath.setAttribute('fill','none');
  visPath.setAttribute('opacity','0.22');
  svg.appendChild(visPath);

  // computer
  const compG = document.createElementNS(svgns,'g'); compG.setAttribute('transform','translate(12,8) scale(1)');
  const compRect = document.createElementNS(svgns,'rect'); compRect.setAttribute('x','0'); compRect.setAttribute('y','0'); compRect.setAttribute('width','48'); compRect.setAttribute('height','32'); compRect.setAttribute('rx','4'); compRect.setAttribute('fill','#111'); compRect.setAttribute('stroke','#ff6b6b');
  compG.appendChild(compRect); svg.appendChild(compG);

  // globe
  const globeG = document.createElementNS(svgns,'g'); globeG.setAttribute('transform','translate(112,2) scale(1)');
  const globeCircle = document.createElementNS(svgns,'circle'); globeCircle.setAttribute('cx','28'); globeCircle.setAttribute('cy','28'); globeCircle.setAttribute('r','24'); globeCircle.setAttribute('fill','#071'); globeCircle.setAttribute('stroke','#ff6b6b'); globeCircle.setAttribute('id','globeCircle');
  globeG.appendChild(globeCircle); svg.appendChild(globeG);

  // target T
  const tG = document.createElementNS(svgns,'g'); tG.setAttribute('transform','translate(212,12) scale(1)');
  const tRect = document.createElementNS(svgns,'rect'); tRect.setAttribute('id','targetT'); tRect.setAttribute('x','0'); tRect.setAttribute('y','0'); tRect.setAttribute('width','24'); tRect.setAttribute('height','24'); tRect.setAttribute('rx','4'); tRect.setAttribute('fill','#111'); tRect.setAttribute('stroke','#ff6b6b');
  const tText = document.createElementNS(svgns,'text'); tText.setAttribute('x','12'); tText.setAttribute('y','16'); tText.setAttribute('font-size','14'); tText.setAttribute('text-anchor','middle'); tText.setAttribute('fill','#ff6b6b'); tText.textContent='T';
  tG.appendChild(tRect); tG.appendChild(tText); svg.appendChild(tG);

  // arrow polygon with animateMotion
  const arrow = document.createElementNS(svgns,'polygon'); arrow.setAttribute('points','0,0 0,6 9,3'); arrow.setAttribute('fill','#ff6b6b');
  const aMotion = document.createElementNS(svgns,'animateMotion'); aMotion.setAttribute('dur','3.6s'); aMotion.setAttribute('repeatCount','indefinite'); aMotion.setAttribute('rotate','auto');
  const mpath = document.createElementNS(svgns,'mpath'); mpath.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href','#' + pid);
  aMotion.appendChild(mpath); arrow.appendChild(aMotion); svg.appendChild(arrow);

  wrap.appendChild(svg); cmdBody.appendChild(wrap); cmdBody.scrollTop = cmdBody.scrollHeight;
  svgContainer = svg;

  // mouse tracking for cursor inject
  svg.addEventListener('mousemove', ev => {
    const rect = svg.getBoundingClientRect();
    const vb = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal : { x:0, y:0, width:240, height:80 };
    const x = ((ev.clientX - rect.left)/rect.width) * vb.width + vb.x;
    const y = ((ev.clientY - rect.top)/rect.height) * vb.height + vb.y;
    lastCursorPos = { x, y };
  });

  svg.addEventListener('click', ev => {
    const rect = svg.getBoundingClientRect();
    const vb = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal : { x:0, y:0, width:240, height:80 };
    const x = ((ev.clientX - rect.left)/rect.width) * vb.width + vb.x;
    const y = ((ev.clientY - rect.top)/rect.height) * vb.height + vb.y;
    lastCursorPos = { x, y };
    appendLine('cursor target set x=' + Math.round(x) + ' y=' + Math.round(y));
  });
}

/* -------------------------
   CONTROL
   ------------------------- */
function cmd_control(){
  if(!listenDone && !svgContainer){ appendLine('Control denied — run listen first'); return; }
  appendLine('[CONTROL MODE ENGAGED]');
  appendLine('(spawn clone, inject, teleport available)');
}

/* -------------------------
   SPAWN CLONE + animate
   - prints IDs for teleport usage
   ------------------------- */
function cmd_spawn_clone(){
  if(!svgContainer){ appendLine('Spawn clone denied — run listen first'); return; }
  if(cloneLayer && cloneLayer.parentNode){
    try{ cloneLayer.parentNode.removeChild(cloneLayer); }catch(e){}
    cloneLayer = null;
  }
  cloneObjects = []; clonesActive = false; animationStopped = false;

  let tx=null, ty=null;
  try{
    const te = svgContainer.querySelector('#targetT');
    if(te){ const b = te.getBBox(); tx = b.x + b.width/2; ty = b.y + b.height/2; }
  }catch(e){}
  if(tx === null || ty === null){
    const vb = svgContainer.viewBox && svgContainer.viewBox.baseVal ? svgContainer.viewBox.baseVal : { x:0, y:0, width:240, height:80 };
    tx = vb.x + vb.width * 0.85; ty = vb.y + vb.height * 0.5;
  }

  appendLine('> Spawning clones to static target T x=' + Math.round(tx) + ' y=' + Math.round(ty), 'cmd-echo');

  const svgns = 'http://www.w3.org/2000/svg';
  const g = document.createElementNS(svgns,'g'); cloneLayer = g;
  svgContainer.appendChild(g);

  const vb2 = svgContainer.viewBox && svgContainer.viewBox.baseVal ? svgContainer.viewBox.baseVal : { x:0, y:0, width:240, height:80 };
  const startBaseX = vb2.x + vb2.width * 0.12;
  const startBaseY = vb2.y + vb2.height * 0.3;

  const createdIds = [];
  for(let i=0;i<CLONE_COUNT;i++){
    const c = document.createElementNS(svgns,'circle');
    c.setAttribute('r', 4);
    c.setAttribute('fill', '#ff6b6b');
    const sx = startBaseX + (Math.random()-0.5)*20;
    const sy = startBaseY + (Math.random()-0.5)*12;
    c.setAttribute('cx', sx);
    c.setAttribute('cy', sy);
    g.appendChild(c);
    const id = 'clone_' + Date.now() + '_' + i;
    cloneObjects.push({ el: c, x: sx, y: sy, targetX: tx, targetY: ty, id: id, index: i });
    createdIds.push(id);
  }

  appendLine('Spawned ' + cloneObjects.length + ' clones. IDs:');
  for(let i=0;i<createdIds.length;i++){
    appendLine(' - ' + createdIds[i] + '  (use: teleport ' + createdIds[i] + '  or  teleport clone ' + i + ')');
  }

  clonesActive = true;
  animationStopped = false;
  const startTime = Date.now();
  let last = null;
  function rafStep(now){
    if(!clonesActive || animationStopped){ clonesActive = false; return; }
    if(!last) last = now;
    const dt = Math.min(64, now - last);
    last = now;
    const elapsed = Date.now() - startTime;
    for(let k=0;k<cloneObjects.length;k++){
      const o = cloneObjects[k];
      let txCur = o.targetX, tyCur = o.targetY;
      if(currentInjectMode === 'random'){ txCur += (Math.random()-0.5)*6; tyCur += (Math.random()-0.5)*6; }
      else if(currentInjectMode === 'cursor'){ txCur = lastCursorPos.x; tyCur = lastCursorPos.y; }
      else if(currentInjectMode === 'pathfinding'){ txCur = o.targetX + Math.sin(Date.now()/300 + o.id.length) * 4; tyCur = o.targetY + Math.cos(Date.now()/300 + o.id.length) * 3; }
      const dx = txCur - o.x, dy = tyCur - o.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist <= 0.9){ o.x = txCur; o.y = tyCur; o.el.setAttribute('cx', o.x); o.el.setAttribute('cy', o.y); continue; }
      const baselinePerMs = CLONE_SPEED / 16.0;
      const stepPx = baselinePerMs * dt;
      if(stepPx >= dist){ o.x = txCur; o.y = tyCur; } else { o.x += (dx / dist) * stepPx; o.y += (dy / dist) * stepPx; }
      o.el.setAttribute('cx', o.x); o.el.setAttribute('cy', o.y);
    }
    if(elapsed < CLONE_DURATION) requestAnimationFrame(rafStep);
    else { clonesActive = false; appendLine('clone sequence complete - ' + Math.round(CLONE_DURATION/1000) + 's elapsed'); }
  }
  requestAnimationFrame(rafStep);
}

/* -------------------------
   LIST objects
   ------------------------- */
function cmd_list_objects(){
  if(cloneObjects.length === 0 && !svgContainer){ appendLine('No objects present'); return; }
  appendLine('Objects:', 'cmd-echo');
  for(let i=0;i<cloneObjects.length;i++){
    const o = cloneObjects[i];
    appendLine(' - index:' + o.index + ' id:' + o.id + ' pos:' + Math.round(o.x) + ',' + Math.round(o.y));
  }
  if(svgContainer){
    const te = svgContainer.querySelector('#targetT');
    if(te){ const b = te.getBBox(); appendLine(' - target T pos:' + Math.round(b.x + b.width/2) + ',' + Math.round(b.y + b.height/2)); }
    const circ = svgContainer.querySelector('#globeCircle');
    if(circ){ const cx = parseFloat(circ.getAttribute('cx')||0); const cy = parseFloat(circ.getAttribute('cy')||0); appendLine(' - globe pos:' + Math.round(cx) + ',' + Math.round(cy)); }
  }
}

/* -------------------------
   TELEPORT('object') implementation
   - accepts exact id, "clone <index>", partial prefix, "target", "globe"
   - teleports object to random location inside svg viewBox (or inside cmd window if no svg)
   - plays zap sound and shows zap ring
   ------------------------- */
function cmd_teleport_param(objName){
  if(!objName){ appendLine('teleport requires an object name e.g. teleport(\"clone_...\")'); return; }
  objName = String(objName).trim().replace(/^['"]|['"]$/g,'');
  appendLine('> Teleport requested for ' + objName, 'cmd-echo');

  // find object
  let found = cloneObjects.find(c => c.id === objName);
  if(!found){
    const mIdx = objName.match(/^clone[#\s]?(\d+)$/i);
    if(mIdx){ const idx = parseInt(mIdx[1], 10); found = cloneObjects.find(c => c.index === idx); }
  }
  if(!found && objName.toLowerCase() === 'clone' && cloneObjects.length === 1) found = cloneObjects[0];
  if(!found && objName.length > 3) found = cloneObjects.find(c => c.id.indexOf(objName) !== -1);
  if(!found && svgContainer){
    if(objName.toLowerCase() === 'target' || objName.toLowerCase() === 't'){ const te = svgContainer.querySelector('#targetT'); if(te) found = { el: te, isRect: true, id: 'target' }; }
    if(!found && objName.toLowerCase() === 'globe'){ const g = svgContainer.querySelector('#globeCircle'); if(g) found = { el: g, id: 'globe' }; }
  }

  if(!found){ appendLine('object not found.'); return; }

  // compute current position
  let old = { x:36, y:24 };
  try{
    if(found.isRect){ const b = found.el.getBBox(); old.x = b.x + b.width/2; old.y = b.y + b.height/2; }
    else if(found.el.tagName && found.el.tagName.toLowerCase() === 'circle'){ old.x = parseFloat(found.el.getAttribute('cx')||0); old.y = parseFloat(found.el.getAttribute('cy')||0); }
    else if(found.el.getBBox){ const b = found.el.getBBox(); old.x = b.x + b.width/2; old.y = b.y + b.height/2; }
  }catch(e){}
  // choose random dest inside viewBox if svg exists
  let nx = 36, ny = 24;
  if(svgContainer){
    const vb = svgContainer.viewBox && svgContainer.viewBox.baseVal ? svgContainer.viewBox.baseVal : { x:0, y:0, width:240, height:80 };
    const margin = 12;
    nx = vb.x + margin + Math.random() * (vb.width - margin*2);
    ny = vb.y + margin + Math.random() * (vb.height - margin*2);
  } else {
    // map into terminal bounds center
    const r = fakeCMD.getBoundingClientRect();
    nx = Math.random() * r.width;
    ny = Math.random() * r.height;
  }

  // show zap flash: visual ring at old pos then at new pos
  showZapAt(old.x, old.y);
  setTimeout(()=>{ showZapAt(nx, ny); }, 140);

  // move object after short delay
  setTimeout(()=>{
    try{
      if(found.el.tagName && found.el.tagName.toLowerCase() === 'circle'){
        found.el.setAttribute('cx', nx); found.el.setAttribute('cy', ny);
        // update clone object
        const co = cloneObjects.find(c => c.el === found.el || c.id === found.id);
        if(co){ co.x = nx; co.y = ny; }
      } else if(found.isRect){
        const w = parseFloat(found.el.getAttribute('width')||24); const h = parseFloat(found.el.getAttribute('height')||24);
        found.el.setAttribute('x', nx - w/2); found.el.setAttribute('y', ny - h/2);
      } else if(found.el && found.el.setAttribute){
        const b = found.el.getBBox();
        found.el.setAttribute('transform', 'translate(' + (nx - (b.x + b.width/2)) + ',' + (ny - (b.y + b.height/2)) + ')');
      }
    }catch(e){}
    appendLine('OBJECT ' + objName + ' HAS BEEN TELEPORTED.');
    // play zap sound
    playZapSound();
  }, 320);
}

/* showZapAt: create a temporary zap ring DOM element (maps SVG coords to page coords) */
function showZapAt(vx, vy){
  ensureWarpContainer();
  // if we have svg, map viewBox coords to page coords
  if(svgContainer){
    const r = svgContainer.getBoundingClientRect();
    const vb = svgContainer.viewBox && svgContainer.viewBox.baseVal ? svgContainer.viewBox.baseVal : { x:0, y:0, width:240, height:80 };
    const px = r.left + ((vx - vb.x) / vb.width) * r.width;
    const py = r.top + ((vy - vb.y) / vb.height) * r.height;
    const el = document.createElement('div');
    el.className = 'zap-ring';
    el.style.left = px + 'px';
    el.style.top = py + 'px';
    el.style.width = '18px';
    el.style.height = '18px';
    warpContainer.appendChild(el);
    // animate
    requestAnimationFrame(()=>{ el.style.transform = 'translate(-50%,-50%) scale(1.8)'; el.style.opacity = '0'; });
    setTimeout(()=>{ try{ warpContainer.removeChild(el); }catch(e){} }, 600);
    return;
  }
  // fallback: center of terminal
  const r = fakeCMD.getBoundingClientRect();
  const el = document.createElement('div');
  el.className = 'zap-ring';
  el.style.left = (r.left + r.width/2) + 'px';
  el.style.top = (r.top + r.height/2) + 'px';
  el.style.width = '22px';
  el.style.height = '22px';
  warpContainer.appendChild(el);
  requestAnimationFrame(()=>{ el.style.transform = 'translate(-50%,-50%) scale(2.4)'; el.style.opacity = '0'; });
  setTimeout(()=>{ try{ warpContainer.removeChild(el); }catch(e){} }, 700);
}

/* -------------------------
   animation.stop(obj?) and destroy(obj?)
   ------------------------- */
function cmd_animation_stop_param(obj){
  if(obj !== undefined && obj !== null){
    appendLine('Animation stopped for ' + String(obj));
  } else {
    if(svgContainer){
      const anims = svgContainer.querySelectorAll('animateMotion');
      anims.forEach(a => { try { a.parentNode.removeChild(a); } catch(e){} });
    }
    animationStopped = true;
    clonesActive = false;
    appendLine('Animation stopped for all');
  }
}
function cmd_destroy_param(obj){
  if(obj !== undefined && obj !== null){
    appendLine('Destroyed ' + String(obj));
    playBoomSound();
  } else {
    if(svgContainer){
      const wrap = svgContainer.parentNode;
      if(wrap && wrap.parentNode) try { wrap.parentNode.removeChild(wrap); } catch(e){}
    }
    svgContainer = null;
    listenDone = false;
    cloneObjects.forEach(o => { try { if(o.el && o.el.parentNode) o.el.parentNode.removeChild(o.el); } catch(e){} });
    cloneObjects = [];
    clonesActive = false;
    appendLine('Destroyed all and reset state');
    playBoomSound();
  }
}

/* -------------------------
   teleport('object') already implemented above
   ------------------------- */

/* -------------------------
   go to('link') - open link in new tab
   ------------------------- */
function cmd_goto_param(link){
  if(!link){ appendLine('go to requires a link'); return; }
  const url = String(link).trim().replace(/^['"]|['"]$/g,'');
  appendLine('Opening ' + url, 'cmd-echo');
  try{
    // basic URL validation: allow http(s) only
    if(!/^https?:\/\//i.test(url)){ appendLine('Invalid url. Use full https://...'); return; }
    window.open(url, '_blank');
  }catch(e){
    appendLine('Failed to open link: ' + String(e));
  }
}

/* -------------------------
   inject mode setter
   ------------------------- */
function cmd_inject(mode){
  const m = (mode || '').trim().toLowerCase();
  if(!m){ appendLine('Specify inject mode random,pathfinding,cursor'); return; }
  if(['random','pathfinding','cursor'].indexOf(m) === -1){ appendLine('Unknown inject mode ' + m); return; }
  currentInjectMode = m;
  appendLine('inject mode set to ' + currentInjectMode);
}

/* -------------------------
   teleport, destroy and animation.stop are also exposed as function-call syntaxes
   parser for both function-call and space separated
   ------------------------- */
function tryParseFunctionCall(input){
  const m = input.trim().match(/^([a-zA-Z0-9_.]+)\s*\(([\s\S]*)\)\s*$/);
  if(!m) return null;
  const name = m[1].trim();
  let rawArg = m[2].trim();
  if(rawArg.length === 0) return { name: name, arg: undefined };
  const q = rawArg.match(/^['"](.*)['"]$/);
  if(q) return { name: name, arg: q[1] };
  return { name: name, arg: rawArg };
}

function handlePlainCommand(raw){
  const parts = raw.trim().split(/\s+/);
  const cmd = parts[0].toLowerCase();
  const rest = parts.slice(1).join(' ');
  if(cmd === 'firewall'){ cmd_firewall(); return; }
  if(cmd === 'hack'){ cmd_hack(); return; }
  if(cmd === 'listen'){ cmd_listen(); return; }
  if(cmd === 'control'){ cmd_control(); return; }
  if((cmd === 'spawn' && parts[1] && parts[1].toLowerCase() === 'clone') || cmd === 'spawn' || cmd === 'clone'){ cmd_spawn_clone(); return; }
  if(cmd === 'inject'){ cmd_inject(rest); return; }
  if(cmd === 'teleport'){ if(rest) cmd_teleport_param(rest.replace(/^['"]|['"]$/g,'')); else appendLine('teleport requires an argument.'); return; }
  if(cmd === 'go' && parts[1] && parts[1].toLowerCase() === 'to'){ if(parts.slice(2).length) cmd_goto_param(parts.slice(2).join(' ')); else appendLine('go to requires a link'); return; }
  if(cmd === 'animation.stop' || (cmd === 'animation' && parts[1] && parts[1].toLowerCase() === 'stop')){ cmd_animation_stop_param(undefined); return; }
  if(cmd === 'destroy'){ cmd_destroy_param(undefined); return; }
  if(cmd === 'list' || cmd === 'ls'){ cmd_list_objects(); return; }
  if(cmd === 'help'){ appendLine('Available commands','cmd-strong'); appendLine('- firewall'); appendLine('- hack'); appendLine('- listen'); appendLine('- control'); appendLine('- spawn clone'); appendLine('- inject <random|pathfinding|cursor>'); appendLine('- teleport(\'obj\') or teleport obj'); appendLine('- go to(\'https://...\' )'); appendLine('- list / ls'); appendLine('- animation.stop(obj?)'); appendLine('- destroy(obj?)'); appendLine('- help'); return; }
  appendLine('Unknown command ' + escapeHtml(raw));
}

/* -------------------------
   Terminal input handling
   ------------------------- */
cmdInput.addEventListener('keydown', function(e){
  if(e.key !== 'Enter') return;
  if(!terminalReady){ appendLine('Terminal not ready'); return; }
  const raw = cmdInput.value.trim();
  cmdInput.value = '';
  if(!raw) return;
  appendLine('> ' + raw, 'cmd-echo');

  const fn = tryParseFunctionCall(raw);
  if(fn){
    const fname = fn.name;
    const arg = fn.arg;
    // function-call style
    if(fname === 'animation.stop' || fname === 'animation_stop'){ cmd_animation_stop_param(arg); return; }
    if(fname === 'destroy'){ cmd_destroy_param(arg); return; }
    if(fname === 'teleport'){ cmd_teleport_param(arg); return; }
    if(fname === 'go' && arg && typeof arg === 'string' && fname.toLowerCase() === 'go'){ cmd_goto_param(arg); return; }
    if(fname === 'goto' || fname === 'go_to'){ cmd_goto_param(arg); return; }
    appendLine('Unknown function ' + fname);
    return;
  }

  handlePlainCommand(raw);
});

/* expose helper functions to console */
window.animation = { stop: cmd_animation_stop_param };
window.destroy = cmd_destroy_param;
window.teleport = cmd_teleport_param;
window.go = cmd_goto_param;
window.C00L = { spawnClone: cmd_spawn_clone, hack: cmd_hack, firewall: cmd_firewall, listen: cmd_listen, control: cmd_control, teleport: cmd_teleport_param, goto: cmd_goto_param };

/* -------------------------
   filler logs (start after terminal ready)
   ------------------------- */
(function filler(){
  const arr = [
    "Initializing packet capture",
    "Monitoring network events",
    "Injecting test packet",
    "Synchronizing clone positions",
    "Rendering SVG overlay",
    "Computing path heuristics",
    "Spawning helper threads",
    "Checking collision avoidance",
    "Logging telemetry",
    "Updating trace routing",
    "Simulating CPU jitter",
    "Sampling entropy pool",
    "Verifying animation state"
  ];
  let i = 0;
  function run(){
    try{ if(terminalReady) appendLine(arr[i%arr.length], 'cmd-echo'); i++; }catch(e){}
    setTimeout(run, 4000);
  }
  setTimeout(()=>{ const t=setInterval(()=>{ if(terminalReady){ clearInterval(t); run(); } },900); },100);
})();

/* -------------------------
   end of script
   ------------------------- */
</script>
</body>
</html>
