<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>C00lGUI — Full Simulator</title>
<style>
/* =========================================================================
   Styles: Keep terminal red theme, readable text, explicit scrollbars.
   This CSS intentionally contains many small rules to be explicit.
   ========================================================================= */
:root{
  --bg:#050405;
  --card:#0b0b0b;
  --red:#ff3b3b;
  --red-deep:#b71c1c;
  --muted:rgba(255,255,255,0.92);
  --mono: "Courier New", Courier, monospace;
}

* { box-sizing: border-box; }
html,body { height:100%; margin:0; background:
  radial-gradient(ellipse at center,#0f0f12 0%, #020202 60%),
  linear-gradient(180deg,#060003 0%, #000 100%);
  color:var(--muted); font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
}

/* Page container and card */
.wrap { min-height:100vh; display:flex; align-items:center; justify-content:center; padding:28px; }
.card {
  width:980px; max-width:96%;
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  border-radius:12px; padding:28px;
  border:1px solid rgba(255,255,255,0.03);
  box-shadow: 0 30px 90px rgba(0,0,0,0.6);
  text-align:center;
}

/* Headings */
.title { font-size:28px; color:var(--red-deep); font-weight:800; margin:0 0 6px 0; text-shadow: 0 0 14px rgba(255,80,80,0.12); }
.subtitle { font-size:14px; color:rgba(255,255,255,0.78); margin:6px 0 16px 0; }

/* Enable terminal as clickable accessible element */
#enableTerminal {
  display:inline-block; padding:10px 14px; border-radius:8px;
  background: rgba(255,255,255,0.01); color:var(--muted);
  cursor:pointer; user-select:none; outline:none;
  border:1px solid rgba(255,255,255,0.02);
}
#enableTerminal:focus { box-shadow: 0 0 0 8px rgba(255,107,107,0.06); }

/* Progress bar - initialization */
.progressBarOuter {
  width:88%; max-width:720px; margin:18px auto 8px auto; background:rgba(255,255,255,0.02);
  border-radius:8px; height:12px; overflow:hidden; border:1px solid rgba(255,255,255,0.02);
}
.progressBarInner { height:12px; width:0%; background: linear-gradient(90deg,var(--red),var(--red-deep)); transition: width 80ms linear; }

/* Fake terminal overlay styling */
#fakeCMD {
  display:none;
  position:fixed;
  top:6vh; left:6vw;
  width:88vw; height:88vh;
  max-width:1280px; max-height:920px;
  background:#070404; color:var(--red);
  border: 3px solid var(--red-deep);
  box-shadow: 0 40px 160px rgba(183,28,28,0.35);
  z-index:99999; border-radius:10px; overflow:hidden;
  font-family: var(--mono);
}

#cmdHeader { display:flex; gap:12px; align-items:center; padding:12px 16px; background: linear-gradient(90deg, rgba(255,0,0,0.02), rgba(255,0,0,0.01)); border-bottom:1px solid rgba(255,0,0,0.04); }
#cmdTitle { font-weight:800; color:var(--red-deep); font-size:16px; }
#cmdClose { margin-left:auto; background:transparent; border:none; color:var(--red); font-weight:700; cursor:pointer; padding:8px 12px; border-radius:6px; }
#cmdClose:hover { background:rgba(255,0,0,0.03); }

/* Terminal text area */
#cmdBody {
  padding:14px 18px;
  height: calc(100% - 120px);
  overflow:auto;
  white-space:pre-wrap;
  font-size:14px;
  line-height:1.45;
  color:var(--red);
  background: linear-gradient(180deg,#040303 0%, #000 100%);
}

/* terminal scrollbar custom (webkit) */
#cmdBody::-webkit-scrollbar { width:10px; height:10px; }
#cmdBody::-webkit-scrollbar-track { background: rgba(0,0,0,0.15); border-radius:6px; }
#cmdBody::-webkit-scrollbar-thumb { background: linear-gradient(180deg, rgba(255,59,59,0.18), rgba(183,28,28,0.28)); border-radius:6px; border: 2px solid rgba(0,0,0,0.14); }

/* Small helper classes */
.cmd-line { margin:6px 0; font-family:var(--mono); color:var(--red); }
.cmd-echo { color:var(--red); font-weight:600; }
.cmd-strong { font-weight:800; color:var(--red); }
.accessDenied { display:block; margin-top:8px; font-weight:900; font-size:34px; color:#ff4d4d; text-shadow:0 0 18px rgba(255,0,0,0.18); letter-spacing:2px; }

/* Input area */
#cmdInputWrap { padding:10px 16px 18px 16px; border-top:1px solid rgba(255,0,0,0.03); display:flex; gap:8px; align-items:center; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); }
#cmdPrompt { font-family:var(--mono); font-size:14px; color:var(--red); }
#cmdInput { flex:1; background:transparent; border:none; outline:none; color:var(--red); font-family:var(--mono); font-size:14px; }

/* Visual area container for SVGs inserted into terminal */
.visual-wrap { margin:12px 0; display:flex; justify-content:center; align-items:center; }
.visual-wrap svg { width:88%; max-width:760px; height:auto; display:block; background:#020202; border-radius:6px; }

/* Accessibility helper */
kbd { background:rgba(255,255,255,0.03); padding:2px 6px; border-radius:6px; font-family:var(--mono); font-size:12px; color:var(--muted); }

/* Responsive adjustments */
@media (max-width:720px){
  .card { padding:16px; }
  .visual-wrap svg { width:100%; }
  #fakeCMD { top:3vh; left:2vw; width:96vw; height:94vh; }
}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="main" aria-live="polite">
      <div class="title">WELCOME BACK C00lKID</div>
      <div class="subtitle">Interactive simulator — client-only</div>

      <!-- Enable Terminal control -->
      <div id="enableTerminal" role="button" tabindex="0" aria-pressed="false">
        Enable terminal..
      </div>

      <!-- Progress bar -->
      <div class="progressBarOuter" aria-hidden="false" style="margin-top:18px;">
        <div id="progressFill" class="progressBarInner" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div>
      </div>

      <div style="color:rgba(255,255,255,0.7); font-size:13px; margin-top:8px;">
        Click the text above or press <kbd>Ctrl + R</kbd> after initialization to open the terminal.
      </div>
    </div>
  </div>

  <!-- Fake CMD overlay -->
  <div id="fakeCMD" role="dialog" aria-modal="true" aria-label="C00lKID Terminal">
    <div id="cmdHeader">
      <div id="cmdTitle">C00lKID TERMINAL</div>
      <div style="font-size:12px;color:rgba(255,255,255,0.12);"> — debug mode</div>
      <button id="cmdClose" aria-label="Close terminal">CLOSE</button>
    </div>

    <div id="cmdBody" tabindex="0" aria-live="polite"></div>

    <div id="cmdInputWrap">
      <div id="cmdPrompt">&gt;</div>
      <input id="cmdInput" autocomplete="off" spellcheck="false" aria-label="Terminal input" />
    </div>
  </div>

<script>
/* =========================================================================
   Full explicit JavaScript — verbose and non-truncated.
   - All commands implemented as separate, long, clear functions.
   - No recursive call patterns causing stack overflow.
   - Animation via requestAnimationFrame.
   - Cursor-mode tracking for 'inject' implemented.
   ========================================================================= */

/* --------------------------
   Element refs and initial state
   -------------------------- */
const enableTerminalEl = document.getElementById('enableTerminal');
const progressFillEl = document.getElementById('progressFill');
const fakeCMD = document.getElementById('fakeCMD');
const cmdBody = document.getElementById('cmdBody');
const cmdInput = document.getElementById('cmdInput');
const cmdClose = document.getElementById('cmdClose');

/* State flags and data structures */
let initialized = false;            // true after 5s init
let progressTimerRef = null;        // reference to init timer
let mainLoadProgress = 0;           // 0..100

let firewallBroken = false;         // set when 'firewall' runs
let hackAttempted = false;          // whether hack was run at least once
let hackSuccessful = false;         // whether hack succeeded (firewallBroken true at completion)
let targetPassword = null;          // generated password on success

let listenDone = false;             // set after 'listen' completes and visual created
let svgContainer = null;            // reference to last network SVG
let svgViewBox = { w: 240, h: 80 }; // standard viewBox for inserted svgs

let controlActive = false;          // set when 'control' executed
let clonesActive = false;           // true while clones animate
let cloneObjects = [];              // array of clone meta objects

let CLONE_DURATION = 5000;          // ms
let CLONE_COUNT = 6;

let currentInjectMode = 'random';   // 'random' | 'pathfinding' | 'cursor'
let lastCursorPos = { x: 120, y: 40 };

/* Misc helper collections */
const generatedPasswords = new Set(); // avoid duplicate passwords in session

/* --------------------------
   Utility helper functions
   -------------------------- */

/**
 * appendLine(text, cls)
 * - Adds a new line of terminal output to #cmdBody.
 * - All colons ":" are removed from displayed text per user's request.
 * - cls optional for CSS class names such as 'cmd-echo', 'cmd-strong'.
 */
function appendLine(text, cls) {
  const el = document.createElement('div');
  el.className = cls ? 'cmd-line ' + cls : 'cmd-line';
  // remove colon characters to match user's instruction
  const safe = String(text).replace(/:/g, '');
  el.innerHTML = safe;
  cmdBody.appendChild(el);
  // auto-scroll to bottom
  cmdBody.scrollTop = cmdBody.scrollHeight;
}

/**
 * escapeHtml(s)
 * - Small helper to escape user-provided strings displayed back to terminal.
 */
function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, function (m) { return ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[m]; });
}

/* --------------------------
   Initialization progress (5 seconds)
   - Update progress bar visually and set initialized flag when done.
   -------------------------- */
(function startInitialization() {
  // total duration desired: 5000ms
  const totalMs = 5000;
  const stepMs = 75;
  const steps = Math.ceil(totalMs / stepMs);
  const increment = 100 / steps;
  mainLoadProgress = 0;
  progressFillEl.style.width = '0%';
  progressFillEl.setAttribute('aria-valuenow', '0');

  progressTimerRef = setInterval(function () {
    mainLoadProgress = Math.min(100, mainLoadProgress + increment);
    progressFillEl.style.width = Math.floor(mainLoadProgress) + '%';
    progressFillEl.setAttribute('aria-valuenow', Math.floor(mainLoadProgress));
    if (mainLoadProgress >= 100) {
      clearInterval(progressTimerRef);
      progressTimerRef = null;
      initialized = true;
      // announce system initialization in the terminal if it were open
      // but do not auto-open terminal — user must click or press ctrl+r
      // we still append a subtle invisible note to DOM for accessibility
      const readyNote = document.createElement('div');
      readyNote.style.color = 'rgba(255,255,255,0.08)';
      readyNote.style.fontSize = '11px';
      readyNote.textContent = '[SYSTEM] Initialization complete';
      // We don't append into cmdBody here to avoid showing small note (user didn't want extra text)
    }
  }, stepMs);
})();

/* --------------------------
   Terminal show/hide
   - showTerminal: open only if initialized true
   - hideTerminal: close overlay and stop running loops if needed
   -------------------------- */
function showTerminal() {
  if (!initialized) {
    // quick feedback pulse
    enableTerminalEl.animate([{ transform: 'scale(0.985)' }, { transform: 'scale(1)' }], { duration: 160 });
    return;
  }
  fakeCMD.style.display = 'block';
  // Clear previous terminal output when opening new session for clarity
  cmdBody.innerHTML = '';
  appendLine('<span style="color:#ff7b7b">[C00lKID TERMINAL v0.1]</span>', 'cmd-echo');
  cmdInput.focus();
}

function hideTerminal() {
  fakeCMD.style.display = 'none';
  // stop long-running intervals if any running hack
  if (hackIntervalRef) {
    clearInterval(hackIntervalRef);
    hackIntervalRef = null;
    runningHack = false;
  }
}

/* Hook enable terminal element for click + keyboard accessibility */
if (enableTerminalEl) {
  enableTerminalEl.addEventListener('click', function () { showTerminal(); });
  enableTerminalEl.addEventListener('keydown', function (e) {
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); showTerminal(); }
  });
}

/* Bind Ctrl+R to open terminal and Escape to close */
window.addEventListener('keydown', function (e) {
  if (e.ctrlKey && e.key.toLowerCase() === 'r') {
    e.preventDefault();
    showTerminal();
  }
  if (e.key === 'Escape') {
    if (fakeCMD.style.display === 'block') hideTerminal();
  }
});
cmdClose.addEventListener('click', hideTerminal);

/* --------------------------
   Command implementations — verbose and explicit
   - Each command is its own function; long comments and step-by-step logs included.
   -------------------------- */

/* FIREWALL
   - Simulate engaging a firewall breaker with step logs.
   - Sets firewallBroken true for subsequent hack success.
*/
function cmd_firewall() {
  if (firewallBroken) {
    appendLine('Firewall breaker already active');
    return;
  }
  appendLine('> Engaging firewall breaker', 'cmd-echo');
  appendLine('Loading firewall bypass modules');
  appendLine('Patching kernel-level signatures');
  appendLine('Injecting temporary hooks into packet filter');
  appendLine('Rewriting access control lists');
  appendLine('Finalizing bypass - testing handshake');
  // small delay simulation
  setTimeout(function () {
    firewallBroken = true;
    appendLine('Firewall breaker engaged You may now run hack');
  }, 650);
}

/* HACK
   - 5 seconds of chaotic terminal output (nonsense logs).
   - If firewallBroken was false at completion => ACCESS DENIED.
   - If firewallBroken was true => success => generate a target password.
*/
let hackIntervalRef = null;
let runningHack = false;
function cmd_hack() {
  if (runningHack) { appendLine('Hack sequence already running'); return; }
  appendLine('> Executing hack sequence', 'cmd-echo');
  runningHack = true;
  hackAttempted = true;
  let ticks = 0;
  const maxTicks = 25; // roughly 5s at 200ms per tick
  const noise = [
    'Loading kernel module OK',
    'Resolving vector signature 0x' + Math.floor(Math.random() * 0xFFFF).toString(16),
    'Spawning rogue thread at 0x' + Math.floor(Math.random() * 0xFFFF).toString(16),
    'Buffering entropy 32%',
    'Hash collision detected retrying',
    'Allocating virtual page ' + Math.floor(Math.random() * 4096),
    'Patching system call table done',
    'Overflowing stack frame warning',
    'Decrypting payload chunk 3/8',
    'Handshake with unknown host established',
    'Randomizing pointers OK',
    'Clearing temp logs',
    'Flushing CPU cache lines',
    'Injecting packet to /dev/null',
    'Kernel panic simulated test mode',
    'Synchronizing with time server fail',
    'Forking zombie processes 7',
    'Simulating memory leak +1.2MB',
    'Overwriting sector 13 done',
    'Triggering ISR vector 0x' + Math.floor(Math.random() * 255).toString(16)
  ];

  hackIntervalRef = setInterval(function () {
    // print a variable number of lines to make output chaotic
    const lines = 1 + Math.floor(Math.random() * 2);
    for (let i = 0; i < lines; i++) {
      const idx = Math.floor(Math.random() * noise.length);
      const text = noise[idx].replace(/\d+/g, function () { return Math.floor(Math.random() * 9999); });
      appendLine(text);
    }
    ticks++;
    if (ticks >= maxTicks) {
      clearInterval(hackIntervalRef);
      hackIntervalRef = null;
      runningHack = false;
      // decide success or fail based on firewallBroken
      if (!firewallBroken) {
        // ACCESS DENIED path
        appendLine('');
        appendLine('<span class="accessDenied">ACCESS DENIED</span>');
        appendLine('Hack sequence terminated due to active firewall policies');
        hackSuccessful = false;
      } else {
        // success path: create a unique target password (client-side)
        targetPassword = genUniquePassword(12);
        appendLine('');
        appendLine('<span class="cmd-strong">target password ' + targetPassword + '</span>');
        hackSuccessful = true;
        appendLine('(run listen next to visualize network; control will be available after listen)');
      }
    }
  }, 200);
}

/* Helper: generate unique pseudo-random password
   - purely client-side; avoids duplicates within the session
*/
function genUniquePassword(len) {
  len = len || 12;
  const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (let attempt = 0; attempt < 5000; attempt++) {
    let s = '';
    for (let i = 0; i < len; i++) s += charset.charAt(Math.floor(Math.random() * charset.length));
    if (!generatedPasswords.has(s)) { generatedPasswords.add(s); return s; }
  }
  // fallback
  let fb = '';
  for (let i = 0; i < len; i++) fb += charset.charAt(Math.floor(Math.random() * charset.length));
  generatedPasswords.add(fb);
  return fb;
}

/* LISTEN
   - Visualizes a network path with an SVG (computer -> globe -> target)
   - Plays some simulated discovery lines while "scanning"
   - Attaches mousemove/click handlers for cursor injection later
*/
function cmd_listen() {
  if (!hackSuccessful) {
    appendLine('Listen denied — run hack and succeed first');
    return;
  }
  if (listenDone) {
    appendLine('Listen already completed');
    return;
  }

  appendLine('> Listening for network endpoints', 'cmd-echo');
  // produce several noise lines to mimic scanning
  const scanNoise = [
    'Probing local network',
    'Collecting ARP table entries',
    'Scanning open ports',
    'Resolving service banners',
    'Estimating latency to hosts',
    'Collecting routing table',
    'Enumerating hosts'
  ];
  let step = 0;
  const maxStep = 14;
  const scanInterval = setInterval(function () {
    const idx = Math.floor(Math.random() * scanNoise.length);
    appendLine(scanNoise[idx] + ' ' + Math.floor(Math.random() * 100));
    step++;
    if (step >= maxStep) {
      clearInterval(scanInterval);
      // create the SVG visual representation
      createNetworkSVG();
      listenDone = true;
      appendLine('');
      appendLine('(listen complete — control available)');
    }
  }, 220);
}

/* createNetworkSVG
   - builds an SVG that shows computer (left) → globe (middle) → target (right)
   - includes a moving arrow (animateMotion) on a path
   - stores svgContainer for later clone injection and cursor tracking
*/
function createNetworkSVG() {
  // wrapper div
  const wrap = document.createElement('div');
  wrap.className = 'visual-wrap';

  const svgns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgns, 'svg');
  svg.setAttribute('viewBox', '0 0 240 80');
  svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
  svg.setAttribute('aria-hidden', 'true');

  // defs with marker and path
  const defs = document.createElementNS(svgns, 'defs');

  // marker for arrowheads (not used by animateMotion polygon but kept for possible static arrows)
  const marker = document.createElementNS(svgns, 'marker');
  marker.setAttribute('id', 'arrowhead_' + Date.now());
  marker.setAttribute('markerWidth', '8');
  marker.setAttribute('markerHeight', '6');
  marker.setAttribute('refX', '8');
  marker.setAttribute('refY', '3');
  marker.setAttribute('orient', 'auto');
  const mpath = document.createElementNS(svgns, 'path');
  mpath.setAttribute('d', 'M0,0 L8,3 L0,6 z');
  mpath.setAttribute('fill', '#ff6b6b');
  marker.appendChild(mpath);
  defs.appendChild(marker);

  // motion path used by animateMotion
  const motionPath = document.createElementNS(svgns, 'path');
  motionPath.setAttribute('id', 'networkPath_' + Date.now());
  motionPath.setAttribute('d', 'M36,24 C80,24 128,36 156,36 C184,36 212,24 212,24');
  motionPath.setAttribute('fill', 'none');
  motionPath.setAttribute('stroke', 'none');
  defs.appendChild(motionPath);

  svg.appendChild(defs);

  // computer (left)
  const computerG = document.createElementNS(svgns, 'g');
  computerG.setAttribute('transform', 'translate(12,8) scale(1)');
  const compRect = document.createElementNS(svgns, 'rect');
  compRect.setAttribute('x', '0'); compRect.setAttribute('y', '0'); compRect.setAttribute('width', '48'); compRect.setAttribute('height', '32');
  compRect.setAttribute('rx', '4'); compRect.setAttribute('ry', '4'); compRect.setAttribute('fill', '#111'); compRect.setAttribute('stroke', '#ff6b6b');
  computerG.appendChild(compRect);
  const compInner = document.createElementNS(svgns, 'rect');
  compInner.setAttribute('x', '4'); compInner.setAttribute('y', '4'); compInner.setAttribute('width', '40'); compInner.setAttribute('height', '20'); compInner.setAttribute('fill', '#030303');
  computerG.appendChild(compInner);
  const compStand = document.createElementNS(svgns, 'rect');
  compStand.setAttribute('x', '12'); compStand.setAttribute('y', '24'); compStand.setAttribute('width', '24'); compStand.setAttribute('height', '4'); compStand.setAttribute('fill', '#0b0b0b'); compStand.setAttribute('stroke', '#ff6b6b');
  computerG.appendChild(compStand);
  svg.appendChild(computerG);

  // globe (center)
  const globeG = document.createElementNS(svgns, 'g');
  globeG.setAttribute('transform', 'translate(112,2) scale(1)');
  const globeCircle = document.createElementNS(svgns, 'circle');
  globeCircle.setAttribute('cx', '28'); globeCircle.setAttribute('cy', '28'); globeCircle.setAttribute('r', '24'); globeCircle.setAttribute('fill', '#071'); globeCircle.setAttribute('stroke', '#ff6b6b');
  globeG.appendChild(globeCircle);
  const globePath1 = document.createElementNS(svgns, 'path');
  globePath1.setAttribute('d', 'M4 28 C12 12, 44 12, 52 28'); globePath1.setAttribute('stroke', '#ff6b6b'); globePath1.setAttribute('stroke-width', '1.2'); globePath1.setAttribute('fill', 'none');
  globeG.appendChild(globePath1);
  const globePath2 = document.createElementNS(svgns, 'path');
  globePath2.setAttribute('d', 'M28 4 C24 16, 24 40, 28 52'); globePath2.setAttribute('stroke', '#ff6b6b'); globePath2.setAttribute('stroke-width', '1.2'); globePath2.setAttribute('fill', 'none');
  globeG.appendChild(globePath2);
  svg.appendChild(globeG);

  // target (right)
  const targG = document.createElementNS(svgns, 'g');
  targG.setAttribute('transform', 'translate(212,12) scale(1)');
  const targRect = document.createElementNS(svgns, 'rect');
  targRect.setAttribute('x', '0'); targRect.setAttribute('y', '0'); targRect.setAttribute('width', '24'); targRect.setAttribute('height', '24'); targRect.setAttribute('rx', '4'); targRect.setAttribute('ry', '4'); targRect.setAttribute('fill', '#111'); targRect.setAttribute('stroke', '#ff6b6b');
  const targText = document.createElementNS(svgns, 'text');
  targText.setAttribute('x', '12'); targText.setAttribute('y', '16'); targText.setAttribute('font-size', '14'); targText.setAttribute('text-anchor', 'middle'); targText.setAttribute('fill', '#ff6b6b');
  targText.textContent = 'T';
  targG.appendChild(targRect); targG.appendChild(targText); svg.appendChild(targG);

  // visible dashed path
  const dashPath = document.createElementNS(svgns, 'path');
  dashPath.setAttribute('d', motionPath.getAttribute('d'));
  dashPath.setAttribute('stroke', '#ff6b6b'); dashPath.setAttribute('stroke-width', '1.2'); dashPath.setAttribute('fill', 'none'); dashPath.setAttribute('stroke-dasharray', '8 6'); dashPath.setAttribute('opacity', '0.22');
  svg.appendChild(dashPath);

  // moving arrow on top — polygon with animateMotion
  const arrowPoly = document.createElementNS(svgns, 'polygon');
  arrowPoly.setAttribute('points', '0,0 0,6 9,3'); arrowPoly.setAttribute('fill', '#ff6b6b');
  const animateMotion = document.createElementNS(svgns, 'animateMotion');
  animateMotion.setAttribute('dur', '3.6s');
  animateMotion.setAttribute('repeatCount', 'indefinite');
  animateMotion.setAttribute('rotate', 'auto');
  const mpathRef = document.createElementNS(svgns, 'mpath');
  // link the path id we created earlier
  mpathRef.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#' + motionPath.getAttribute('id'));
  animateMotion.appendChild(mpathRef);
  arrowPoly.appendChild(animateMotion);
  svg.appendChild(arrowPoly);

  wrap.appendChild(svg);
  cmdBody.appendChild(wrap);
  cmdBody.scrollTop = cmdBody.scrollHeight;

  // remember svg container
  svgContainer = svg;
  svgViewBox = { w: 240, h: 80 };

  // attach mousemove for cursor mode tracking
  svgContainer.addEventListener('mousemove', function (ev) {
    const rect = svgContainer.getBoundingClientRect();
    const x = ((ev.clientX - rect.left) / rect.width) * svgViewBox.w;
    const y = ((ev.clientY - rect.top) / rect.height) * svgViewBox.h;
    lastCursorPos = { x: x, y: y };
  });

  // attach click to set explicit cursor target
  svgContainer.addEventListener('click', function (ev) {
    const rect = svgContainer.getBoundingClientRect();
    const x = ((ev.clientX - rect.left) / rect.width) * svgViewBox.w;
    const y = ((ev.clientY - rect.top) / rect.height) * svgViewBox.h;
    lastCursorPos = { x: x, y: y };
    appendLine('cursor target set x=' + Math.round(x) + ' y=' + Math.round(y));
  });
}

/* CONTROL
   - must run after listen is complete
   - allows spawn clone and inject to operate
*/
function cmd_control() {
  if (!listenDone) {
    appendLine('Control denied — run listen to map network first');
    return;
  }
  if (controlActive) {
    appendLine('Control already active');
    return;
  }
  controlActive = true;
  appendLine('[CONTROL MODE ENGAGED]');
  appendLine('(spawn clone, inject, teleport now available)');
}

/* SPAWN CLONE (core of the system)
   - must be called when controlActive === true
   - spawns CLONE_COUNT clones at the target position and animates them for CLONE_DURATION ms
   - movement responds live to currentInjectMode variable (so inject commands issued later affect active clones)
   - animation uses requestAnimationFrame (no recursion)
*/
function cmd_spawn_clone() {
  if (!controlActive) {
    appendLine('Spawn clone denied — control not active');
    return;
  }
  if (!svgContainer) {
    appendLine('No network visual present — run listen first');
    return;
  }
  if (clonesActive) {
    appendLine('Clones already active (wait until current sequence finishes)');
    return;
  }

  appendLine('> Spawning clones (detailed sequence)', 'cmd-echo');

  // create a layer group in the svg to hold clones
  const svgns = "http://www.w3.org/2000/svg";
  const layer = document.createElementNS(svgns, 'g');
  const layerId = 'cloneLayer_' + Date.now();
  layer.setAttribute('id', layerId);
  svgContainer.appendChild(layer);

  // prepare clones meta objects
  cloneObjects = [];
  for (let i = 0; i < CLONE_COUNT; i++) {
    const c = document.createElementNS(svgns, 'circle');
    // starting at target approximate coords (rightmost)
    const startX = 212 + (Math.random() - 0.5) * 6;
    const startY = 24 + (Math.random() - 0.5) * 6;
    c.setAttribute('cx', startX);
    c.setAttribute('cy', startY);
    c.setAttribute('r', 3.2);
    c.setAttribute('fill', '#ff6b6b');
    c.setAttribute('opacity', '0.98');
    layer.appendChild(c);

    const obj = {
      el: c,
      startX: startX,
      startY: startY,
      // used by random mode for small jitter
      vx: (Math.random() - 0.5) * 0.6,
      vy: (Math.random() - 0.5) * 0.4,
      // target if in pathfinding mode
      targetX: 36,
      targetY: 24,
      id: 'clone-' + i
    };
    cloneObjects.push(obj);
  }

  clonesActive = true;
  const beginTime = Date.now();

  // animateFrame updates clones positions each frame based on currentInjectMode
  function animateFrame() {
    const now = Date.now();
    const elapsed = now - beginTime;
    const norm = Math.min(1, elapsed / CLONE_DURATION); // normalized 0..1

    // update each clone
    for (let i = 0; i < cloneObjects.length; i++) {
      const c = cloneObjects[i];
      let cx = parseFloat(c.el.getAttribute('cx'));
      let cy = parseFloat(c.el.getAttribute('cy'));

      if (currentInjectMode === 'random') {
        // random wandering with drift leftwards
        const jitterX = (Math.sin((elapsed / 180) + i) * 8) * (1 - norm);
        const jitterY = (Math.cos((elapsed / 240) + i) * 6) * (1 - norm);
        const baseX = c.startX - (160 * norm); // left drift across duration
        const baseY = c.startY + Math.sin((i + norm) * 6) * 2;
        cx = baseX + jitterX;
        cy = baseY + jitterY;

      } else if (currentInjectMode === 'pathfinding') {
        // ease from start to target (easeOutCubic)
        const u = 1 - Math.pow(1 - norm, 3);
        const nx = c.startX + (c.targetX - c.startX) * u;
        const ny = c.startY + (c.targetY - c.startY) * u + Math.sin((i + norm) * 6) * 1.5;
        cx = nx;
        cy = ny;

      } else if (currentInjectMode === 'cursor') {
        // move towards lastCursorPos (smoothed)
        const tx = lastCursorPos.x || c.targetX;
        const ty = lastCursorPos.y || c.targetY;
        const u2 = 1 - Math.pow(1 - norm, 2);
        const nx = c.startX + (tx - c.startX) * u2;
        const ny = c.startY + (ty - c.startY) * u2;
        cx = nx;
        cy = ny;
      }

      c.el.setAttribute('cx', cx);
      c.el.setAttribute('cy', cy);
    }

    // print verbose telemetry periodically for long-form logs
    if (Math.floor(elapsed / 900) !== Math.floor((elapsed - 40) / 900)) {
      appendLine('clone telemetry update t=' + Math.floor(elapsed) + 'ms');
    }

    if (elapsed < CLONE_DURATION && clonesActive) {
      requestAnimationFrame(animateFrame);
    } else {
      // sequence ends
      clonesActive = false;
      appendLine('clone sequence complete - ' + (CLONE_DURATION / 1000) + 's elapsed');
      appendLine('(clones spawned and remain at final positions; use inject for next spawn)');
      // keep clones in place (do not remove) so user can inspect; removal could be added
      // but leave them to show final positions
    }
  }

  // start the animation loop
  requestAnimationFrame(animateFrame);
}

/* cmd_inject
   - set current inject mode; active clone animation picks up the new mode immediately
*/
function cmd_inject(arg) {
  if (!controlActive) {
    appendLine('Inject denied — control not active');
    return;
  }
  if (!arg) {
    appendLine('Specify inject mode: random pathfinding cursor');
    return;
  }
  const mode = arg.trim().toLowerCase();
  if (mode !== 'random' && mode !== 'pathfinding' && mode !== 'cursor') {
    appendLine('Unknown inject mode ' + arg + ' - valid: random, pathfinding, cursor');
    return;
  }
  currentInjectMode = mode;
  appendLine('inject mode set to ' + currentInjectMode);
  if (clonesActive) appendLine('(Active clones will adopt the new mode immediately)');
  if (mode === 'cursor') appendLine('(Move your mouse inside the network visual to direct clones)');
}

/* cmd_teleport
   - simple visual teleport: animates a particle along a reverse path and nudges clone positions
*/
function cmd_teleport() {
  if (!controlActive) {
    appendLine('Teleport denied — control not active');
    return;
  }
  if (!svgContainer) {
    appendLine('No visual present — run listen first');
    return;
  }
  appendLine('> Establishing teleport transfer', 'cmd-echo');

  // make particle
  const svgns = "http://www.w3.org/2000/svg";
  const particle = document.createElementNS(svgns, 'circle');
  particle.setAttribute('r', '3.5'); particle.setAttribute('fill', '#ff6b6b'); particle.setAttribute('opacity', '0.98');
  particle.setAttribute('cx', 212); particle.setAttribute('cy', 24);
  svgContainer.appendChild(particle);

  const duration = 2400;
  const start = Date.now();
  const pathPoints = [
    { x: 212, y: 24 },
    { x: 160, y: 30 },
    { x: 110, y: 26 },
    { x: 36, y: 24 }
  ];

  function lerp(a, b, t) { return a + (b - a) * t; }

  (function animateParticle() {
    const now = Date.now();
    const elapsed = now - start;
    const t = Math.min(1, elapsed / duration);
    const segCount = pathPoints.length - 1;
    const segT = t * segCount;
    const segIdx = Math.min(segCount - 1, Math.floor(segT));
    const localT = segT - segIdx;
    const p0 = pathPoints[segIdx];
    const p1 = pathPoints[segIdx + 1];
    const nx = lerp(p0.x, p1.x, localT);
    const ny = lerp(p0.y, p1.y, localT);
    particle.setAttribute('cx', nx);
    particle.setAttribute('cy', ny);
    if (t < 1) {
      requestAnimationFrame(animateParticle);
    } else {
      // cleanup particle
      if (particle.parentNode) particle.parentNode.removeChild(particle);
      appendLine('transfer complete');
    }
  })();

  // nudge clones slightly to simulate "delivery"
  for (let i = 0; i < cloneObjects.length; i++) {
    const c = cloneObjects[i];
    const cx = parseFloat(c.el.getAttribute('cx'));
    const cy = parseFloat(c.el.getAttribute('cy'));
    const nx = cx + (Math.random() - 0.5) * 16;
    const ny = cy + (Math.random() - 0.5) * 10;
    c.el.setAttribute('cx', nx);
    c.el.setAttribute('cy', ny);
  }
}

/* --------------------------
   Input handling and command router
   - verbose mapping, long-form error messages
   -------------------------- */
cmdInput.addEventListener('keydown', function (e) {
  if (e.key === 'Enter') {
    const raw = cmdInput.value.trim();
    cmdInput.value = '';
    if (raw.length === 0) return;
    appendLine('> ' + escapeHtml(raw), 'cmd-echo');

    // parse command and args
    const tokens = raw.split(/\s+/);
    const command = tokens[0].toLowerCase();
    const args = tokens.slice(1);

    // explicit command routing
    if (command === 'firewall') {
      cmd_firewall();
      return;
    }
    if (command === 'hack') {
      cmd_hack();
      return;
    }
    if (command === 'listen') {
      cmd_listen();
      return;
    }
    if (command === 'control') {
      cmd_control();
      return;
    }
    if (command === 'spawn' && args[0] && args[0].toLowerCase() === 'clone') {
      cmd_spawn_clone();
      return;
    }
    if (command === 'spawn' && !args[0]) {
      // accept 'spawn' as alias for spawn clone
      cmd_spawn_clone();
      return;
    }
    if (command === 'clone') {
      cmd_spawn_clone();
      return;
    }
    if (command === 'inject') {
      const m = args.join(' ').trim();
      if (!m) {
        appendLine('Specify inject mode: random pathfinding cursor');
        return;
      }
      cmd_inject(m);
      return;
    }
    if (command === 'teleport') {
      cmd_teleport();
      return;
    }
    if (command === 'help') {
      // long help output
      appendLine('Available commands', 'cmd-strong');
      appendLine('- firewall        Engage firewall breaker (must run before hack to succeed)');
      appendLine('- hack            Run hack sequence (~5s). If firewall active result is ACCESS DENIED');
      appendLine('- listen          Discover target and display visual (run after successful hack)');
      appendLine('- control         Engage control mode (enabled after listen)');
      appendLine('- spawn clone     Spawn multiple clone entities (5s animation). Requires control');
      appendLine('- inject <mode>   Set movement injection mode for clones. modes: random pathfinding cursor');
      appendLine('- teleport        Teleport simulation between target and user');
      appendLine('- help            Show this help (verbose)');
      return;
    }

    // default unknown command
    appendLine('Unknown command ' + escapeHtml(raw));
  }
});

/* --------------------------
   Cursor support & attach click to latest visual wrapper
   - Periodically attach click listener to the latest visual so user can click to set a target
   -------------------------- */
function attachCursorClicksToLatestVisual() {
  const visuals = cmdBody.querySelectorAll('.visual-wrap svg');
  if (!visuals || visuals.length === 0) return;
  const latest = visuals[visuals.length - 1];
  if (!latest) return;

  // Avoid attaching multiple identical handlers: use a property flag
  if (latest.__hasCursorClick) return;
  latest.__hasCursorClick = true;

  latest.addEventListener('click', function (ev) {
    const rect = latest.getBoundingClientRect();
    const vb = latest.viewBox.baseVal || { x: 0, y: 0, width: 240, height: 80 };
    const x = ((ev.clientX - rect.left) / rect.width) * vb.width + vb.x;
    const y = ((ev.clientY - rect.top) / rect.height) * vb.height + vb.y;
    lastCursorPos = { x: x, y: y };
    appendLine('cursor target set x=' + Math.round(x) + ' y=' + Math.round(y));
  });

  // also support mousemove to continually update lastCursorPos for 'cursor' mode
  latest.addEventListener('mousemove', function (ev) {
    const rect = latest.getBoundingClientRect();
    const vb = latest.viewBox.baseVal || { x: 0, y: 0, width: 240, height: 80 };
    const x = ((ev.clientX - rect.left) / rect.width) * vb.width + vb.x;
    const y = ((ev.clientY - rect.top) / rect.height) * vb.height + vb.y;
    lastCursorPos = { x: x, y: y };
  });
}

// Periodically try to attach cursor handlers to newly appended visuals
const attachCursorInterval = setInterval(function () {
  attachCursorClicksToLatestVisual();
}, 700);

/* --------------------------
   Clean up on page unload
   -------------------------- */
window.addEventListener('beforeunload', function () {
  if (progressTimerRef) clearInterval(progressTimerRef);
  if (hackIntervalRef) clearInterval(hackIntervalRef);
  clearInterval(attachCursorInterval);
});

/* End of script */
</script>
</body>
</html>
