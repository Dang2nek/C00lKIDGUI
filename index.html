<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>C00lGUI</title>
<style>
  :root{
    --bg:#0b0b0b;
    --red:#ff3b3b;
    --red-deep:#b71c1c;
    --muted:rgba(255,255,255,0.90);
    --mono: "Courier New", Courier, monospace;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:
    radial-gradient(ellipse at center, #0f0f12 0%, #050405 60%), linear-gradient(180deg,#100 0%, #000 100%);
    color:var(--muted); font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  }

  /* Layout */
  .center { min-height:100vh; display:flex; align-items:center; justify-content:center; padding:24px; }
  .card {
    width:920px; max-width:96%;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.03);
    border-radius:12px; padding:24px; text-align:center;
    box-shadow: 0 30px 80px rgba(0,0,0,0.6);
  }

  .title { font-size:26px; color:var(--red-deep); margin:0 0 6px 0; font-weight:700; text-shadow:0 0 14px rgba(255,80,80,0.14); }
  .sub { color:rgba(255,255,255,0.78); margin-bottom:12px; }

  /* load area */
  #loadBox {
    background: linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
    border-radius:10px; padding:16px; border:1px solid rgba(255,255,255,0.02);
  }
  #progressBar {
    width:84%; height:14px; margin:12px auto 8px auto; background:rgba(255,255,255,0.02);
    border-radius:8px; overflow:hidden; border:1px solid rgba(255,255,255,0.03);
  }
  #progressFill { height:100%; width:0%; background: linear-gradient(90deg,var(--red),var(--red-deep)); transition:width 120ms linear; }
  #progressText { font-size:13px; color:rgba(255,255,255,0.78); margin-top:8px; }

  /* Fake terminal */
  #fakeCMD {
    display:none; position:fixed; top:6vh; left:6vw;
    width:88vw; height:88vh; max-width:1280px; max-height:920px;
    background: #070404; border: 3px solid var(--red-deep);
    box-shadow: 0 30px 140px rgba(183,28,28,0.45);
    z-index:99999; border-radius:10px; overflow:hidden;
    font-family: var(--mono);
  }
  #cmdHeader { display:flex; align-items:center; gap:12px; padding:12px 16px; background: linear-gradient(90deg, rgba(255,0,0,0.02), rgba(255,0,0,0.01)); border-bottom:1px solid rgba(255,0,0,0.04); }
  #cmdTitle { font-weight:700; color:var(--red-deep); }
  #cmdClose { margin-left:auto; background:transparent; border:none; color:var(--red); font-weight:700; cursor:pointer; padding:8px 12px; border-radius:6px; }
  #cmdClose:hover { background:rgba(255,0,0,0.03); }

  /* terminal text all red */
  #cmdBody { padding:16px; height: calc(100% - 120px); overflow:auto; white-space:pre-wrap; font-size:14px; line-height:1.45; color:var(--red); background:#040303; }
  .cmd-line { color:var(--red); margin:4px 0; font-family:var(--mono); }
  .cmd-echo { color:var(--red); }
  .cmd-strong { color:var(--red); font-weight:700; }
  .accessDenied { display:block; margin-top:8px; font-weight:900; font-size:36px; color:#ff4d4d; text-shadow:0 0 18px rgba(255,0,0,0.18); letter-spacing:2px; }

  #cmdInputWrap { padding:10px 16px 18px 16px; border-top:1px solid rgba(255,0,0,0.03); display:flex; gap:8px; align-items:center; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); }
  #cmdPrompt { color:var(--red); font-family:var(--mono); font-size:14px; }
  #cmdInput { flex:1; background:transparent; border:none; outline:none; color:var(--red); font-family:var(--mono); font-size:14px; }

  /* listen visual inside terminal */
  .listen-visual { display:flex; justify-content:center; align-items:center; margin:18px 0; width:100%; position:relative; }
  .listen-visual svg { width:88%; max-width:760px; height:auto; display:block; }

  /* virus and teleport visuals */
  .virus-visual, .teleport-visual, .clone-visual { display:flex; justify-content:center; align-items:center; margin:12px 0; width:100%; position:relative; }
  .virus-visual svg, .teleport-visual svg, .clone-visual svg { width:88%; max-width:760px; height:auto; display:block; }

  @media (max-width:720px){
    .card { padding:14px; }
    #progressBar { width:92%; }
    .listen-visual svg, .virus-visual svg, .teleport-visual svg, .clone-visual svg { width:100%; }
    #fakeCMD { top:3vh; left:2vw; width:96vw; height:94vh; }
  }
</style>
</head>
<body>
  <div class="center">
    <div class="card" role="main" aria-live="polite">
      <div class="title">WELCOME BACK C00lKID</div>
      <div class="sub">enable terminal..</div>

      <div id="loadBox" aria-hidden="false">
        <div id="progressBar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
          <div id="progressFill" aria-hidden="true"></div>
        </div>
        <div id="progressText">Initializing terminal 0%</div>
      </div>
    </div>
  </div>

  <!-- Fake CMD overlay -->
  <div id="fakeCMD" role="dialog" aria-modal="true" aria-label="Fake command prompt">
    <div id="cmdHeader">
      <div id="cmdTitle">C00lKID TERMINAL</div>
      <div style="font-size:12px;color:rgba(255,255,255,0.12);"> — debug mode</div>
      <button id="cmdClose" aria-label="Close terminal">CLOSE</button>
    </div>

    <div id="cmdBody" tabindex="0" aria-live="polite" aria-atomic="false"></div>

    <div id="cmdInputWrap">
      <div id="cmdPrompt">&gt;</div>
      <input id="cmdInput" autocomplete="off" spellcheck="false" aria-label="Terminal input" />
    </div>
  </div>

<script>
(function(){
  // refs
  const progressFill = document.getElementById('progressFill');
  const progressText = document.getElementById('progressText');
  const fakeCMD = document.getElementById('fakeCMD');
  const cmdBody = document.getElementById('cmdBody');
  const cmdInput = document.getElementById('cmdInput');
  const cmdClose = document.getElementById('cmdClose');
  const loadBox = document.getElementById('loadBox');

  // state
  let mainLoaded = false;
  let loadingInterval = null;

  // command states
  let firewallBroken = false;
  let listenAvailable = false;
  let listenDone = false;
  let controlAllowed = false;
  let runningHack = false;
  let hackTimer = null;
  let controlRan = false;

  const generatedPasswords = new Set();

  const nonsenseSamples = [
    "Loading kernel module OK",
    "Resolving vector signature 0x" + Math.floor(Math.random()*0xFFFF).toString(16),
    "Spawning rogue thread at 0x" + Math.floor(Math.random()*0xFFFF).toString(16),
    "Buffering entropy 32%",
    "Hash collision detected retrying",
    "Allocating virtual page " + Math.floor(Math.random()*4096),
    "Patching system call table done",
    "Overflowing stack frame warning",
    "Decrypting payload chunk 3/8",
    "Handshake with unknown host established",
    "Randomizing pointers OK",
    "Clearing temp logs",
    "Flushing CPU cache lines",
    "Injecting packet to /dev/null",
    "Kernel panic simulated (test mode)",
    "Synchronizing with time server fail",
    "Forking zombie processes 7",
    "Simulating memory leak +1.2MB",
    "Overwriting sector 13 done",
    "Triggering ISR vector 0x" + Math.floor(Math.random()*255).toString(16)
  ];

  // append (all displayed text will have ':' removed)
  function appendLine(text, cls){
    const el = document.createElement('div');
    el.className = cls ? 'cmd-line ' + cls : 'cmd-line';
    const safe = String(text).replace(/:/g, '');
    el.innerHTML = safe;
    cmdBody.appendChild(el);
    cmdBody.scrollTop = cmdBody.scrollHeight;
  }

  // loading progress 5s
  function startLoading(){
    let progress = 0;
    const duration = 5000;
    const step = 100;
    const steps = duration / step;
    const inc = 100 / steps;
    progressFill.style.width = '0%';
    progressText.textContent = 'Initializing terminal 0%';
    loadingInterval = setInterval(()=>{
      progress = Math.min(100, progress + inc);
      progressFill.style.width = progress + '%';
      progressText.textContent = 'Initializing terminal ' + Math.floor(progress) + '%';
      progressFill.parentElement.setAttribute('aria-valuenow', Math.floor(progress));
      if(progress >= 100){
        clearInterval(loadingInterval);
        mainLoaded = true;
        progressText.textContent = 'Terminal enabled';
      }
    }, step);
  }
  startLoading();

  // show/hide terminal
  function showTerminal(){
    if(!mainLoaded){
      const orig = progressText.textContent;
      progressText.textContent = 'Terminal locked — initializing';
      progressText.style.color = 'rgba(255,120,120,1)';
      setTimeout(()=>{ progressText.textContent = orig; progressText.style.color = ''; }, 700);
      return;
    }
    fakeCMD.style.display = 'block';
    cmdBody.innerHTML = '';
    appendLine('[C00lKID TERMINAL v0.1]', 'cmd-echo');
    cmdInput.focus();
  }
  function hideTerminal(){
    fakeCMD.style.display = 'none';
    if(runningHack){
      runningHack = false;
      if(hackTimer) clearInterval(hackTimer);
    }
  }
  cmdClose.addEventListener('click', hideTerminal);

  // block reload and open terminal on Ctrl+R
  window.addEventListener('keydown', (e)=>{
    if(e.ctrlKey && e.key.toLowerCase() === 'r'){
      e.preventDefault();
      showTerminal();
    }
    if(e.key === 'Escape' && fakeCMD.style.display === 'block'){
      hideTerminal();
    }
  });

  // unique password generator
  function genUniquePassword(len = 12){
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+";
    for(let a=0;a<2000;a++){
      let pw = '';
      for(let i=0;i<len;i++) pw += chars.charAt(Math.floor(Math.random()*chars.length));
      if(!generatedPasswords.has(pw)){ generatedPasswords.add(pw); return pw; }
    }
    let fb = '';
    for(let i=0;i<len;i++) fb += chars.charAt(Math.floor(Math.random()*chars.length));
    generatedPasswords.add(fb); return fb;
  }

  // hack (5s nonsense); if firewallBroken false -> ACCESS DENIED, else generate password and enable listen
  function runFakeHack(){
    if(runningHack) { appendLine('Hack already running'); return; }
    runningHack = true;
    appendLine('> Executing hack sequence', 'cmd-echo');
    let ticks = 0; const maxTicks = 25;
    hackTimer = setInterval(()=>{
      const lines = 1 + Math.floor(Math.random()*2);
      for(let i=0;i<lines;i++){
        const idx = Math.floor(Math.random()*nonsenseSamples.length);
        appendLine(nonsenseSamples[idx].replace(/\d+/g, ()=>Math.floor(Math.random()*9999)));
      }
      ticks++;
      if(ticks >= maxTicks || !runningHack){
        clearInterval(hackTimer);
        runningHack = false;
        if(!firewallBroken){
          appendLine('');
          appendLine('<span class="accessDenied">ACCESS DENIED</span>');
        } else {
          const pw = genUniquePassword(12);
          appendLine('');
          appendLine('<span class="cmd-strong">target password ' + pw + '</span>');
          listenAvailable = true;
          listenDone = false;
          controlAllowed = false;
          appendLine('(run listen next to map network then control will be allowed)');
        }
        cmdInput.focus();
      }
    }, 200);
  }

  // firewall
  function runFirewall(){
    if(firewallBroken){ appendLine('Firewall already disabled'); return; }
    firewallBroken = true;
    appendLine('Firewall breaker engaged You may now run hack');
  }

  // listen: requires listenAvailable; shows SVG (path hidden in defs) and places arrow on top
  function runListen(){
    if(!listenAvailable){ appendLine('Listen denied — no target discovered Run firewall then hack first'); return; }
    if(listenDone){ appendLine('Listen already completed'); return; }

    appendLine('> Listening for network endpoints', 'cmd-echo');
    let ticks = 0; const maxTicks = 14;
    const t = setInterval(()=>{
      const idx = Math.floor(Math.random()*nonsenseSamples.length);
      appendLine(nonsenseSamples[idx].replace(/\d+/g, ()=>Math.floor(Math.random()*9999)));
      ticks++;
      if(ticks >= maxTicks){
        clearInterval(t);
        const wrapper = document.createElement('div');
        wrapper.className = 'listen-visual';
        wrapper.innerHTML = `
<svg viewBox="0 0 240 80" xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true">
  <!-- computer -->
  <g transform="translate(12,8) scale(1)">
    <rect x="0" y="0" width="48" height="32" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>
    <rect x="4" y="4" width="40" height="20" fill="#030303"/>
    <rect x="12" y="24" width="24" height="4" fill="#0b0b0b" stroke="#ff6b6b"/>
  </g>

  <!-- globe -->
  <g transform="translate(112,2) scale(1)">
    <circle cx="28" cy="28" r="24" fill="#071" stroke="#ff6b6b"/>
    <path d="M4 28 C12 12, 44 12, 52 28" stroke="#ff6b6b" stroke-width="2" fill="none"/>
    <path d="M28 4 C24 16, 24 40, 28 52" stroke="#ff6b6b" stroke-width="2" fill="none"/>
  </g>

  <!-- target -->
  <g transform="translate(212,12) scale(1)">
    <rect x="0" y="0" width="24" height="24" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>
    <text x="12" y="16" font-size="16" text-anchor="middle" fill="#ff6b6b">T</text>
  </g>

  <!-- hidden motion path in defs -->
  <defs>
    <path id="motionPath" d="M36,24 C80,24 128,36 156,36 C184,36 212,24 212,24" fill="none" stroke="none"/>
    <!-- reverse path for teleport (T -> user) -->
    <path id="motionPathReverse" d="M212,24 C184,36 156,36 128,36 C80,24 36,24 36,24" fill="none" stroke="none"/>
  </defs>

  <!-- visible dashed path -->
  <path d="M36,24 C80,24 128,36 156,36 C184,36 212,24 212,24"
        stroke="#ff6b6b" stroke-width="2" fill="none" stroke-dasharray="8 6" opacity="0.25">
    <animate attributeName="stroke-dashoffset" from="0" to="14" dur="0.8s" repeatCount="indefinite"/>
  </path>

  <!-- moving arrow polygon placed last so it's on top -->
  <g>
    <polygon points="0,0 0,6 9,3" fill="#ff6b6b">
      <animateMotion dur="3.6s" repeatCount="indefinite" rotate="auto">
        <mpath xlink:href="#motionPath"/>
      </animateMotion>
    </polygon>
  </g>
</svg>
        `;
        cmdBody.appendChild(wrapper);
        listenDone = true;
        controlAllowed = true;
        appendLine('');
        appendLine('(listen complete — control available)');
        cmdInput.focus();
      }
    }, 200);
  }

  // control: show virus svg moving along same path to T
  function runControl(){
    if(!controlAllowed){ appendLine('Control denied — run listen after a successful hack to enable control'); return; }

    appendLine('[CONTROL MODE ENGAGED]');

    // create virus visual element and append to terminal
    const vwrap = document.createElement('div');
    vwrap.className = 'virus-visual';
    vwrap.innerHTML = `
<svg viewBox="0 0 240 80" xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true">
  <!-- computer/globe/target drawn first so virus appears on top -->
  <g transform="translate(12,8) scale(1)">
    <rect x="0" y="0" width="48" height="32" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>
    <rect x="4" y="4" width="40" height="20" fill="#030303"/>
    <rect x="12" y="24" width="24" height="4" fill="#0b0b0b" stroke="#ff6b6b"/>
  </g>

  <g transform="translate(112,2) scale(1)">
    <circle cx="28" cy="28" r="24" fill="#071" stroke="#ff6b6b"/>
  </g>

  <g transform="translate(212,12) scale(1)">
    <rect x="0" y="0" width="24" height="24" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>
    <text x="12" y="16" font-size="16" text-anchor="middle" fill="#ff6b6b">T</text>
  </g>

  <defs>
    <path id="motionPathControl" d="M36,24 C80,24 128,36 156,36 C184,36 212,24 212,24" fill="none" stroke="none"/>
    <!-- small spiky virus shape as symbol -->
    <g id="virusShape">
      <circle cx="0" cy="0" r="6" fill="#ff6b6b" stroke="#b71c1c" stroke-width="1"/>
      <g stroke="#b71c1c" stroke-width="1">
        <line x1="-9" y1="0" x2="-5" y2="0"/>
        <line x1="9" y1="0" x2="5" y2="0"/>
        <line x1="0" y1="-9" x2="0" y2="-5"/>
        <line x1="0" y1="9" x2="0" y2="5"/>
        <line x1="-6" y1="-6" x2="-3" y2="-3"/>
        <line x1="6" y1="-6" x2="3" y2="-3"/>
        <line x1="-6" y1="6" x2="-3" y2="3"/>
        <line x1="6" y1="6" x2="3" y2="3"/>
      </g>
    </g>
  </defs>

  <!-- optional faint path to show route -->
  <path d="M36,24 C80,24 128,36 156,36 C184,36 212,24 212,24"
        stroke="#ff6b6b" stroke-width="1" fill="none" opacity="0.12" stroke-dasharray="6 6"/>

  <!-- virus group on top that follows the motion path -->
  <g>
    <use href="#virusShape" x="0" y="0">
      <animateMotion dur="3.6s" repeatCount="1" rotate="auto" fill="freeze">
        <mpath xlink:href="#motionPathControl"/>
      </animateMotion>
    </use>
  </g>
</svg>
    `;
    cmdBody.appendChild(vwrap);
    cmdBody.scrollTop = cmdBody.scrollHeight;

    // run simulated control output in parallel while virus moves
    let ticks = 0; const max = 18;
    const ctl = setInterval(()=>{
      const idx = Math.floor(Math.random()*nonsenseSamples.length);
      appendLine(nonsenseSamples[idx].replace(/\d+/g, ()=>Math.floor(Math.random()*9999)));
      ticks++;
      if(ticks >= max){
        clearInterval(ctl);
        appendLine('[CONTROL TERMINATED]');
        controlRan = true;
        cmdInput.focus();
      }
    }, 200);
  }

  // teleport: requires controlRan true
  function runTeleport(){
    if(!controlRan){ appendLine('Teleport denied — run control first'); return; }

    appendLine('> Establishing teleport sequence', 'cmd-echo');
    // create teleport svg showing a particle moving from T back along reverse path to user
    const twrap = document.createElement('div');
    twrap.className = 'teleport-visual';
    twrap.innerHTML = `
<svg viewBox="0 0 240 80" xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true">
  <!-- minimal scene so particle appears over route -->
  <g transform="translate(12,8) scale(1)">
    <rect x="0" y="0" width="48" height="32" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>
  </g>
  <g transform="translate(112,2) scale(1)">
    <circle cx="28" cy="28" r="24" fill="#071" stroke="#ff6b6b"/>
  </g>
  <g transform="translate(212,12) scale(1)">
    <rect x="0" y="0" width="24" height="24" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>
    <text x="12" y="16" font-size="16" text-anchor="middle" fill="#ff6b6b">T</text>
  </g>

  <defs>
    <path id="motionPathReverseControl" d="M212,24 C184,36 156,36 128,36 C80,24 36,24 36,24" fill="none" stroke="none"/>
  </defs>

  <!-- faint route -->
  <path d="M212,24 C184,36 156,36 128,36 C80,24 36,24 36,24" stroke="#ff6b6b" stroke-width="1" fill="none" opacity="0.08" stroke-dasharray="6 6"/>

  <!-- teleport particle traveling from T to user -->
  <g>
    <circle r="4" fill="#ff6b6b" opacity="0.95">
      <animateMotion dur="2.6s" repeatCount="1" rotate="auto" fill="freeze">
        <mpath xlink:href="#motionPathReverseControl"/>
      </animateMotion>
    </circle>
  </g>
</svg>
    `;
    cmdBody.appendChild(twrap);
    cmdBody.scrollTop = cmdBody.scrollHeight;

    // print progress
    let p = 0;
    const pT = setInterval(()=>{
      p += 20;
      appendLine('establishing teleport progress ' + p + '%');
      if(p >= 100){
        clearInterval(pT);
        appendLine('transfer complete');
        cmdInput.focus();
      }
    }, 520);
  }

  // spawn clone: requires controlRan true
  function runSpawnClone(){
    if(!controlRan){ appendLine('Spawn clone denied — run control first'); return; }

    appendLine('> Spawning clone from target', 'cmd-echo');

    // create clone svg: multiple small dots emanate from T then settle
    const cwrap = document.createElement('div');
    cwrap.className = 'clone-visual';
    cwrap.innerHTML = `
<svg viewBox="0 0 240 80" xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true">
  <g transform="translate(212,12) scale(1)">
    <rect x="0" y="0" width="24" height="24" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>
    <text x="12" y="16" font-size="16" text-anchor="middle" fill="#ff6b6b">T</text>
  </g>

  <defs>
    <!-- short radial paths for clones to travel outward -->
    <path id="c1" d="M212,24 l-20 -8" fill="none" stroke="none"/>
    <path id="c2" d="M212,24 l-18 6" fill="none" stroke="none"/>
    <path id="c3" d="M212,24 l-28 0" fill="none" stroke="none"/>
    <path id="c4" d="M212,24 l-24 -14" fill="none" stroke="none"/>
    <path id="c5" d="M212,24 l-30 10" fill="none" stroke="none"/>
  </defs>

  <!-- clones (small dots) -->
  <g>
    <circle r="3" fill="#ff6b6b" cx="212" cy="24">
      <animateMotion dur="1.2s" repeatCount="1" fill="freeze">
        <mpath xlink:href="#c1"/>
      </animateMotion>
    </circle>
    <circle r="3" fill="#ff6b6b" cx="212" cy="24">
      <animateMotion dur="1.3s" begin="0.05s" repeatCount="1" fill="freeze">
        <mpath xlink:href="#c2"/>
      </animateMotion>
    </circle>
    <circle r="3" fill="#ff6b6b" cx="212" cy="24">
      <animateMotion dur="1.4s" begin="0.1s" repeatCount="1" fill="freeze">
        <mpath xlink:href="#c3"/>
      </animateMotion>
    </circle>
    <circle r="3" fill="#ff6b6b" cx="212" cy="24">
      <animateMotion dur="1.25s" begin="0.07s" repeatCount="1" fill="freeze">
        <mpath xlink:href="#c4"/>
      </animateMotion>
    </circle>
    <circle r="3" fill="#ff6b6b" cx="212" cy="24">
      <animateMotion dur="1.35s" begin="0.12s" repeatCount="1" fill="freeze">
        <mpath xlink:href="#c5"/>
      </animateMotion>
    </circle>
  </g>
</svg>
    `;
    cmdBody.appendChild(cwrap);
    cmdBody.scrollTop = cmdBody.scrollHeight;

    // simulate cloning progress
    let step = 0;
    const s = setInterval(()=>{
      step++;
      appendLine('cloning target chunk ' + step + ' of 5');
      if(step >= 5){
        clearInterval(s);
        appendLine('clone complete');
        cmdInput.focus();
      }
    }, 450);
  }

  // commands handler
  function handleCommand(raw){
    const cmd = (raw||'').trim().toLowerCase();
    if(cmd === '') return;
    appendLine('> ' + raw, 'cmd-echo');
    if(cmd === 'firewall'){ runFirewall(); return; }
    if(cmd === 'hack'){ runFakeHack(); return; }
    if(cmd === 'listen'){ runListen(); return; }
    if(cmd === 'control'){ runControl(); return; }
    if(cmd === 'teleport'){ runTeleport(); return; }
    if(cmd === 'spawn clone' || cmd === 'spawn' || cmd === 'clone'){ runSpawnClone(); return; }
    appendLine('Unknown command ' + raw);
  }

  // input handling
  cmdInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){
      const val = cmdInput.value;
      cmdInput.value = '';
      if(!mainLoaded){ appendLine('Terminal not ready'); return; }
      handleCommand(val);
    } else if(e.key === 'Escape'){
      hideTerminal();
    }
  });

  // click to open when ready
  loadBox.addEventListener('click', ()=>{ if(mainLoaded) showTerminal(); });

})();
</script>
</body>
</html>
