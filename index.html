<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>C00lGUI - Full Terminal Simulator</title>
<style>
/* ========================================================
   Styling - terminal, cards, progress, visuals
   All terminal text rendered in red-like color per request
   ======================================================== */
:root{
  --bg:#050405;
  --panel:#0b0b0b;
  --red:#ff3b3b;
  --red-deep:#b71c1c;
  --muted:rgba(255,255,255,0.92);
  --mono: "Courier New", Courier, monospace;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:
  radial-gradient(ellipse at center, #0a0a0f 0%, #020202 60%), linear-gradient(180deg,#0b0000 0%, #000 100%);
  color:var(--muted); font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
}

/* Container */
.wrap {
  min-height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:24px;
}

/* Card */
.card {
  width:960px;
  max-width:96%;
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  border:1px solid rgba(255,255,255,0.03);
  border-radius:12px;
  padding:28px;
  text-align:center;
  box-shadow: 0 30px 80px rgba(0,0,0,0.6);
}

/* Title */
.title {
  font-size:28px;
  color:var(--red-deep);
  margin:0 0 6px 0;
  font-weight:800;
  text-shadow:0 0 14px rgba(255,80,80,0.14);
}
.sub { color:rgba(255,255,255,0.78); margin-bottom:14px; }

/* Loading area */
#loadBox {
  background: linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));
  border-radius:10px;
  padding:18px;
  border:1px solid rgba(255,255,255,0.02);
}
#progressBar {
  width:86%;
  height:14px;
  margin:12px auto 8px auto;
  background:rgba(255,255,255,0.02);
  border-radius:8px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,0.03);
}
#progressFill { height:100%; width:0%; background: linear-gradient(90deg,var(--red),var(--red-deep)); transition:width 120ms linear; }
#progressText { font-size:13px; color:rgba(255,255,255,0.78); margin-top:8px; }

/* Terminal overlay */
#fakeCMD {
  display:none;
  position:fixed;
  top:6vh; left:6vw;
  width:88vw; height:88vh;
  max-width:1280px; max-height:920px;
  background: #070404;
  border: 3px solid var(--red-deep);
  box-shadow: 0 30px 140px rgba(183,28,28,0.45);
  z-index:99999;
  border-radius:10px;
  overflow:hidden;
  font-family: var(--mono);
}
#cmdHeader { display:flex; align-items:center; gap:12px; padding:12px 16px; background: linear-gradient(90deg, rgba(255,0,0,0.02), rgba(255,0,0,0.01)); border-bottom:1px solid rgba(255,0,0,0.04); }
#cmdTitle { font-weight:800; color:var(--red-deep); }
#cmdClose { margin-left:auto; background:transparent; border:none; color:var(--red); font-weight:700; cursor:pointer; padding:8px 12px; border-radius:6px; }
#cmdClose:hover { background:rgba(255,0,0,0.03); }

/* Terminal body: ALL TEXT RED */
#cmdBody {
  padding:16px;
  height: calc(100% - 120px);
  overflow:auto;
  white-space:pre-wrap;
  font-size:14px;
  line-height:1.45;
  color:var(--red);
  background: linear-gradient(180deg,#040303 0%, #010101 100%);
}
.cmd-line { color:var(--red); margin:4px 0; font-family:var(--mono); }
.cmd-echo { color:var(--red); font-weight:600; }
.cmd-strong { color:var(--red); font-weight:800; }
.accessDenied { display:block; margin-top:8px; font-weight:900; font-size:36px; color:#ff4d4d; text-shadow:0 0 18px rgba(255,0,0,0.18); letter-spacing:2px; }

/* Input */
#cmdInputWrap { padding:10px 16px 18px 16px; border-top:1px solid rgba(255,0,0,0.03); display:flex; gap:8px; align-items:center; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); }
#cmdPrompt { color:var(--red); font-family:var(--mono); font-size:14px; }
#cmdInput { flex:1; background:transparent; border:none; outline:none; color:var(--red); font-family:var(--mono); font-size:14px; }

/* Visual containers inside terminal */
.visual-wrap { display:flex; justify-content:center; align-items:center; margin:14px 0; width:100%; }
.visual-wrap svg { width:86%; max-width:760px; height:auto; display:block; }

/* minor responsiveness */
@media (max-width:700px){
  .card { padding:12px; }
  #progressBar { width:92%; }
  .visual-wrap svg { width:100%; }
  #fakeCMD { top:3vh; left:2vw; width:96vw; height:94vh; }
}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="main" aria-live="polite">
      <div class="title">WELCOME BACK C00lKID</div>
      <div class="sub">enable terminal..</div>

      <div id="loadBox" aria-hidden="false">
        <div id="progressBar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
          <div id="progressFill" aria-hidden="true"></div>
        </div>
        <div id="progressText">Initializing terminal 0%</div>
      </div>
    </div>
  </div>

  <!-- Fake terminal -->
  <div id="fakeCMD" role="dialog" aria-modal="true" aria-label="Fake command prompt">
    <div id="cmdHeader">
      <div id="cmdTitle">C00lKID TERMINAL</div>
      <div style="font-size:12px;color:rgba(255,255,255,0.12);"> — debug mode</div>
      <button id="cmdClose" aria-label="Close terminal">CLOSE</button>
    </div>

    <div id="cmdBody" tabindex="0" aria-live="polite" aria-atomic="false"></div>

    <div id="cmdInputWrap">
      <div id="cmdPrompt">&gt;</div>
      <input id="cmdInput" autocomplete="off" spellcheck="false" aria-label="Terminal input" />
    </div>
  </div>

<script>
/* =========================================================================
   Full, non-truncated JavaScript controlling terminal simulation.
   This file intentionally verbose: lots of comments and step-by-step logic.
   ========================================================================= */

/* ------------------------
   Element references
   ------------------------ */
const progressFill = document.getElementById('progressFill');
const progressText = document.getElementById('progressText');
const fakeCMD = document.getElementById('fakeCMD');
const cmdBody = document.getElementById('cmdBody');
const cmdInput = document.getElementById('cmdInput');
const cmdClose = document.getElementById('cmdClose');
const loadBox = document.getElementById('loadBox');

/* ------------------------
   State variables
   ------------------------ */
/* Boot/loading state */
let mainLoaded = false;
let loadingInterval = null;

/* Security & command states - explicit flags for each phase */
let firewallBroken = false;     // true after firewall breaker runs
let hackDone = false;           // true after hack sequence finished (success or failure)
let listenAvailable = false;    // true if hack produced a target password
let listenDone = false;         // true after listen finished and visual displayed
let controlAllowed = false;     // true after listen finishes
let controlRan = false;         // true after control completes
let clonesActive = false;       // whether clones are currently spawned and animating
let currentInjectMode = 'random'; // inject mode default
let cloneObjects = [];          // array to hold clone metadata
let generatedPasswords = new Set(); // track generated target passwords (avoid duplicates in session)

/* Timers and intervals */
let hackInterval = null;
let listenInterval = null;
let cloneInterval = null;
let controlInterval = null;

/* Visual settings */
const CLONE_COUNT = 6;          // number of clones to spawn by default
const CLONE_DURATION = 5000;    // clone animation duration in ms (5 seconds)

/* Nonsense lines for terminal to print during sequences (kept verbose) */
const noiseSamples = [
  "Loading kernel module OK",
  "Resolving vector signature 0x" + Math.floor(Math.random()*0xFFFF).toString(16),
  "Spawning rogue thread at 0x" + Math.floor(Math.random()*0xFFFF).toString(16),
  "Buffering entropy 32%",
  "Hash collision detected retrying",
  "Allocating virtual page " + Math.floor(Math.random()*4096),
  "Patching system call table done",
  "Overflowing stack frame warning",
  "Decrypting payload chunk 3/8",
  "Handshake with unknown host established",
  "Randomizing pointers OK",
  "Clearing temp logs",
  "Flushing CPU cache lines",
  "Injecting packet to /dev/null",
  "Kernel panic simulated (test mode)",
  "Synchronizing with time server fail",
  "Forking zombie processes 7",
  "Simulating memory leak +1.2MB",
  "Overwriting sector 13 done",
  "Triggering ISR vector 0x" + Math.floor(Math.random()*255).toString(16)
];

/* ------------------------
   Helper functions
   ------------------------ */

/**
 * appendLine
 * Append a single line to the terminal (cmdBody).
 * All ":" characters are removed from displayed text per requirement.
 * cls optional allows marking the line (cmd-echo / cmd-strong, etc).
 */
function appendLine(text, cls) {
  const el = document.createElement('div');
  el.className = cls ? 'cmd-line ' + cls : 'cmd-line';
  // sanitize: remove literal colon characters
  const safe = String(text).replace(/:/g, '');
  el.innerHTML = safe;
  cmdBody.appendChild(el);
  // auto-scroll
  cmdBody.scrollTop = cmdBody.scrollHeight;
}

/**
 * escapeHtml - small helper if required to escape user input for safe display
 */
function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[m]; });
}

/**
 * genUniquePassword(len)
 * Generate a pseudo-random "target password" which is tracked in a Set to avoid duplicates.
 * Not connected to any server/service — purely client-side random string.
 */
function genUniquePassword(len = 12) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+";
  for (let attempt = 0; attempt < 5000; attempt++) {
    let pw = '';
    for (let i = 0; i < len; i++) pw += chars.charAt(Math.floor(Math.random() * chars.length));
    if (!generatedPasswords.has(pw)) {
      generatedPasswords.add(pw);
      return pw;
    }
  }
  // fallback if extremely unlucky
  let fb = '';
  for (let i = 0; i < len; i++) fb += chars.charAt(Math.floor(Math.random() * chars.length));
  generatedPasswords.add(fb);
  return fb;
}

/* ------------------------
   Loading / Progress (5s)
   - Show progress bar for exactly 5 seconds
   - When finished, set mainLoaded = true
   - Clicking the loadBox opens terminal only if mainLoaded
   ------------------------ */
function startLoading() {
  let duration = 5000;      // 5 seconds total
  let stepMs = 100;         // update every 100ms
  let steps = duration / stepMs;
  let increment = 100 / steps;
  let progress = 0;
  progressFill.style.width = '0%';
  progressText.textContent = 'Initializing terminal 0%';
  let ticks = 0;

  loadingInterval = setInterval(function() {
    ticks++;
    progress = Math.min(100, progress + increment);
    progressFill.style.width = progress + '%';
    progressText.textContent = 'Initializing terminal ' + Math.floor(progress) + '%';
    progressFill.parentElement.setAttribute('aria-valuenow', Math.floor(progress));
    if (ticks >= steps) {
      clearInterval(loadingInterval);
      mainLoaded = true;
      progressText.textContent = 'Terminal enabled';
      appendLine('[SYSTEM] Initialization complete', 'cmd-echo');
      // final small note - no instruction line per request
    }
  }, stepMs);
}

/* ------------------------
   Terminal show/hide controls
   - Ctrl+R opens terminal (blocked reload)
   - Escape closes terminal
   ------------------------ */
function showTerminal() {
  if (!mainLoaded) {
    const orig = progressText.textContent;
    progressText.textContent = 'Terminal locked — initializing';
    progressText.style.color = 'rgba(255,120,120,1)';
    setTimeout(function() {
      progressText.textContent = orig;
      progressText.style.color = '';
    }, 700);
    return;
  }
  fakeCMD.style.display = 'block';
  cmdBody.innerHTML = '';
  appendLine('[C00lKID TERMINAL v0.1]', 'cmd-echo');
  // intentionally do NOT print instruction line (user requested removal)
  // focus input
  cmdInput.focus();
}

function hideTerminal() {
  fakeCMD.style.display = 'none';
  // stop any running sequences to be safe
  if (hackInterval) {
    clearInterval(hackInterval);
    hackInterval = null;
  }
  if (listenInterval) {
    clearInterval(listenInterval);
    listenInterval = null;
  }
  if (cloneInterval) {
    clearInterval(cloneInterval);
    cloneInterval = null;
  }
  if (controlInterval) {
    clearInterval(controlInterval);
    controlInterval = null;
  }
}

/* Attach keyboard handlers */
window.addEventListener('keydown', function(e) {
  // Ctrl+R - open terminal, block reload
  if (e.ctrlKey && e.key.toLowerCase() === 'r') {
    e.preventDefault();
    showTerminal();
  }
  // ESC to close terminal
  if (e.key === 'Escape' && fakeCMD.style.display === 'block') {
    hideTerminal();
  }
});

cmdClose.addEventListener('click', hideTerminal);

/* ------------------------
   Commands implementations (full explicit logic)
   Commands:
     - firewall
     - hack
     - listen
     - control
     - spawn clone
     - teleport
     - inject <mode>   (modes: random, pathfinding, cursor)
   ------------------------ */

/* firewall:
   - toggles firewallBroken true
   - prints multiple lines to simulate engagement
*/
function cmd_firewall() {
  // If already broken, inform
  if (firewallBroken) {
    appendLine('Firewall already disabled');
    return;
  }

  // Step-by-step verbose logs to simulate action
  appendLine('> Engaging firewall breaker', 'cmd-echo');
  appendLine('Loading firewall module stub');
  appendLine('Patching ACL rules');
  appendLine('Bypassing kernel-level DPI signatures');
  appendLine('Applying temporary kernel hooks');
  // final outcome:
  firewallBroken = true;
  appendLine('Firewall breaker engaged You may now run hack');
}

/* hack:
   - Requires firewallBroken true to succeed.
   - Runs ~5s of noise lines, if firewallBroken false -> ACCESS DENIED.
   - If success: generate target password (unique), set listenAvailable true
*/
function cmd_hack() {
  if (hackInterval !== null) {
    appendLine('Hack already running');
    return;
  }

  appendLine('> Executing hack sequence', 'cmd-echo');

  // variables for the sequence
  let ticks = 0, maxTicks = 25; // 25 * 200ms = ~5s
  let running = true;

  hackInterval = setInterval(function() {
    // produce 1-3 lines per tick for chaotic output
    let lines = 1 + Math.floor(Math.random() * 2);
    for (let i = 0; i < lines; i++) {
      let idx = Math.floor(Math.random() * noiseSamples.length);
      // replace numbers in string to create variation
      let text = noiseSamples[idx].replace(/\d+/g, function(){ return Math.floor(Math.random() * 9999); });
      appendLine(text);
    }
    ticks++;

    // finish condition
    if (ticks >= maxTicks || !running) {
      clearInterval(hackInterval);
      hackInterval = null;
      // result depends on firewallBroken
      if (!firewallBroken) {
        // ACCESS DENIED branch - long form
        appendLine('');
        appendLine('<span class="accessDenied">ACCESS DENIED</span>');
        appendLine('Hack sequence terminated due to active firewall policies');
        // mark hackDone true to indicate attempt occurred (user asked hack must run before control? keep hackDone true)
        hackDone = true;
      } else {
        // success branch - generate password & enable listen
        const pw = genUniquePassword(12);
        appendLine('');
        // per user's request remove colons: show "target password <value>"
        appendLine('<span class="cmd-strong">target password ' + pw + '</span>');
        listenAvailable = true;
        listenDone = false;
        controlAllowed = false;
        hackDone = true;
        appendLine('(run listen next to map network then control will be allowed)');
      }
    }
  }, 200);
}

/* listen:
   - Must be run after hack produced a password (listenAvailable true)
   - Runs ~3s of simulated detection then inserts visual SVG
   - Visual contains:
       * computer, globe, target (T)
       * motion path in defs (hidden)
       * moving arrow/dot on top of objects (ensure arrow is appended after the objects)
   - Sets listenDone true and controlAllowed true when finished.
*/
function cmd_listen() {
  if (!listenAvailable) {
    appendLine('Listen denied — no target discovered Run firewall then hack first');
    return;
  }
  if (listenInterval !== null) {
    appendLine('Listen sequence already running');
    return;
  }
  if (listenDone) {
    appendLine('Listen already completed');
    return;
  }

  appendLine('> Listening for network endpoints', 'cmd-echo');

  let ticks = 0, maxTicks = 14;
  listenInterval = setInterval(function() {
    let idx = Math.floor(Math.random() * noiseSamples.length);
    appendLine(noiseSamples[idx].replace(/\d+/g, function(){ return Math.floor(Math.random() * 9999); }));
    ticks++;
    if (ticks >= maxTicks) {
      clearInterval(listenInterval);
      listenInterval = null;

      // Insert the listen SVG visual into terminal
      const wrapper = document.createElement('div');
      wrapper.className = 'visual-wrap';
      // Long, explicit SVG markup ensures arrow is on top (arrow group appended last)
      wrapper.innerHTML = '' +
        '<svg viewBox="0 0 240 80" xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true">' +
        '  <!-- computer (left) -->' +
        '  <g transform="translate(12,8) scale(1)">' +
        '    <rect x="0" y="0" width="48" height="32" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>' +
        '    <rect x="4" y="4" width="40" height="20" fill="#030303"/>' +
        '    <rect x="12" y="24" width="24" height="4" fill="#0b0b0b" stroke="#ff6b6b"/>' +
        '  </g>' +
        '  <!-- globe (middle) -->' +
        '  <g transform="translate(112,2) scale(1)">' +
        '    <circle cx="28" cy="28" r="24" fill="#071" stroke="#ff6b6b"/>' +
        '    <path d="M4 28 C12 12, 44 12, 52 28" stroke="#ff6b6b" stroke-width="2" fill="none"/>' +
        '    <path d="M28 4 C24 16, 24 40, 28 52" stroke="#ff6b6b" stroke-width="2" fill="none"/>' +
        '  </g>' +
        '  <!-- target (right) -->' +
        '  <g transform="translate(212,12) scale(1)">' +
        '    <rect x="0" y="0" width="24" height="24" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>' +
        '    <text x="12" y="16" font-size="16" text-anchor="middle" fill="#ff6b6b">T</text>' +
        '  </g>' +
        '  <!-- motion path (hidden, used by animateMotion) -->' +
        '  <defs>' +
        '    <path id="motionPath_listen" d="M36,24 C80,24 128,36 156,36 C184,36 212,24 212,24" fill="none" stroke="none"/>' +
        '  </defs>' +
        '  <!-- dashed visible path (faint) -->' +
        '  <path d="M36,24 C80,24 128,36 156,36 C184,36 212,24 212,24" stroke="#ff6b6b" stroke-width="2" fill="none" stroke-dasharray="8 6" opacity="0.22">' +
        '    <animate attributeName="stroke-dashoffset" from="0" to="14" dur="0.8s" repeatCount="indefinite"/>' +
        '  </path>' +
        '  <!-- moving arrow on top - appended last so it displays above objects -->' +
        '  <g>' +
        '    <polygon points="0,0 0,6 9,3" fill="#ff6b6b">' +
        '      <animateMotion dur="3.6s" repeatCount="indefinite" rotate="auto">' +
        '        <mpath xlink:href="#motionPath_listen"/>' +
        '      </animateMotion>' +
        '    </polygon>' +
        '  </g>' +
        '</svg>';

      cmdBody.appendChild(wrapper);
      listenDone = true;
      controlAllowed = true;
      appendLine('');
      appendLine('(listen complete — control available)');
      cmdInput.focus();
    }
  }, 200);
}

/* control:
   - Requires controlAllowed true (i.e., listenDone)
   - Shows a virus SVG that moves along the same motion path to T (one-time)
   - Simulates control output in terminal while animation runs
*/
function cmd_control() {
  if (!controlAllowed) {
    appendLine('Control denied — run listen after a successful hack to enable control');
    return;
  }
  appendLine('[CONTROL MODE ENGAGED]');

  // Insert virus visual which will animate once
  const vwrap = document.createElement('div');
  vwrap.className = 'visual-wrap';
  vwrap.innerHTML = '' +
    '<svg viewBox="0 0 240 80" xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true">' +
    '  <g transform="translate(12,8) scale(1)">' +
    '    <rect x="0" y="0" width="48" height="32" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>' +
    '  </g>' +
    '  <g transform="translate(112,2) scale(1)">' +
    '    <circle cx="28" cy="28" r="24" fill="#071" stroke="#ff6b6b"/>' +
    '  </g>' +
    '  <g transform="translate(212,12) scale(1)">' +
    '    <rect x="0" y="0" width="24" height="24" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>' +
    '    <text x="12" y="16" font-size="16" text-anchor="middle" fill="#ff6b6b">T</text>' +
    '  </g>' +
    '  <defs>' +
    '    <path id="motionPath_control" d="M36,24 C80,24 128,36 156,36 C184,36 212,24 212,24" fill="none" stroke="none"/>' +
    '    <g id="virusShape">' +
    '      <circle cx="0" cy="0" r="6" fill="#ff6b6b" stroke="#b71c1c" stroke-width="1"/>' +
    '      <g stroke="#b71c1c" stroke-width="1">' +
    '        <line x1="-9" y1="0" x2="-5" y2="0"/>' +
    '        <line x1="9" y1="0" x2="5" y2="0"/>' +
    '        <line x1="0" y1="-9" x2="0" y2="-5"/>' +
    '        <line x1="0" y1="9" x2="0" y2="5"/>' +
    '      </g>' +
    '    </g>' +
    '  </defs>' +
    '  <path d="M36,24 C80,24 128,36 156,36 C184,36 212,24 212,24" stroke="#ff6b6b" stroke-width="1" fill="none" opacity="0.12" stroke-dasharray="6 6"/>' +
    '  <g>' +
    '    <use href="#virusShape" x="0" y="0">' +
    '      <animateMotion dur="3.6s" repeatCount="1" rotate="auto" fill="freeze">' +
    '        <mpath xlink:href="#motionPath_control"/>' +
    '      </animateMotion>' +
    '    </use>' +
    '  </g>' +
    '</svg>';

  cmdBody.appendChild(vwrap);
  cmdBody.scrollTop = cmdBody.scrollHeight;

  // Simulate control output while virus moves (~3.6s -> make output slightly longer)
  let steps = 0;
  controlInterval = setInterval(function() {
    let idx = Math.floor(Math.random() * noiseSamples.length);
    appendLine(noiseSamples[idx].replace(/\d+/g, function(){ return Math.floor(Math.random() * 9999); }));
    steps++;
    if (steps > 18) {
      clearInterval(controlInterval);
      controlInterval = null;
      appendLine('[CONTROL TERMINATED]');
      controlRan = true;
      // clones and teleport become available now
      appendLine('(control complete — spawn clone, teleport, inject available)');
    }
  }, 200);
}

/* spawn clone:
   - requires controlRan true
   - spawns multiple clones (CLONE_COUNT) inside an SVG container
   - clones animate for CLONE_DURATION (5 seconds) and then finishing message printed
   - each clone is represented by a circle element; movement logic handled per-frame to allow inject modes
*/
function cmd_spawn_clone() {
  if (!controlRan) {
    appendLine('Spawn clone denied — run control first');
    return;
  }
  if (clonesActive) {
    appendLine('Clones already active');
    return;
  }

  appendLine('> Spawning clones (detailed sequence)', 'cmd-echo');

  // Create container and explicit SVG; each clone circle is given an id 'clone-N'
  const cwrap = document.createElement('div');
  cwrap.className = 'visual-wrap';
  // We'll create an inline SVG where clone circles will be appended dynamically
  cwrap.innerHTML = '' +
    '<svg id="cloneSVG" viewBox="0 0 240 80" xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true">' +
    '  <g transform="translate(12,8) scale(1)">' +
    '    <rect x="0" y="0" width="48" height="32" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>' +
    '  </g>' +
    '  <g transform="translate(112,2) scale(1)">' +
    '    <circle cx="28" cy="28" r="24" fill="#071" stroke="#ff6b6b"/>' +
    '  </g>' +
    '  <g transform="translate(212,12) scale(1)">' +
    '    <rect x="0" y="0" width="24" height="24" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>' +
    '    <text x="12" y="16" font-size="16" text-anchor="middle" fill="#ff6b6b">T</text>' +
    '  </g>' +
    '</svg>';

  cmdBody.appendChild(cwrap);
  cmdBody.scrollTop = cmdBody.scrollHeight;

  // Prepare clones
  const svg = document.getElementById('cloneSVG');
  cloneObjects = []; // reset
  for (let i = 0; i < CLONE_COUNT; i++) {
    // Create a circle element representing a clone starting at the target T coordinates (roughly x=212,y=24)
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute('cx', 212);
    circle.setAttribute('cy', 24);
    circle.setAttribute('r', 3.2);
    circle.setAttribute('fill', '#ff6b6b');
    circle.setAttribute('id', 'clone-' + i);
    svg.appendChild(circle);

    // store metadata for each clone for per-frame movement
    cloneObjects.push({
      id: 'clone-' + i,
      el: circle,
      // initial velocity random small for visual jitter in random mode
      vx: (Math.random() - 0.5) * 0.6,
      vy: (Math.random() - 0.5) * 0.4,
      // target for pathfinding (by default go to left side near computer)
      targetX: 36, // left computer area x
      targetY: 24,
      // internal state
      progress: 0
    });
  }

  clonesActive = true;

  // start a high-frequency interval to animate clones per-frame for CLONE_DURATION
  const startTime = Date.now();
  appendLine('spawn sequence initiated - running for ' + (CLONE_DURATION/1000) + 's');

  cloneInterval = setInterval(function() {
    const now = Date.now();
    const elapsed = now - startTime;
    const t = Math.min(1, elapsed / CLONE_DURATION); // normalized 0..1
    // For each clone, update position according to currentInjectMode
    for (let i = 0; i < cloneObjects.length; i++) {
      const c = cloneObjects[i];
      // read current position
      let cx = parseFloat(c.el.getAttribute('cx'));
      let cy = parseFloat(c.el.getAttribute('cy'));
      // move based on inject mode
      if (currentInjectMode === 'random') {
        // random wandering: add small noise based on sine/cos and random jitter
        const jitterX = (Math.sin((t + i) * 12 + Math.random()*2) * 40 * (1 - t));
        const jitterY = (Math.cos((t + i) * 8 + Math.random()*2) * 20 * (1 - t));
        // gradually move away from target (simulate spread)
        const baseX = 212 - (180 * t); // move leftwards overall
        const baseY = 24 + Math.sin((t + i) * 6) * 6;
        c.el.setAttribute('cx', baseX + jitterX);
        c.el.setAttribute('cy', baseY + jitterY);
      } else if (currentInjectMode === 'pathfinding') {
        // smoothly interpolate from T (212,24) to clone.targetX/Y using ease
        const sx = 212;
        const sy = 24;
        const tx = c.targetX;
        const ty = c.targetY;
        // use easeOutCubic for nicer motion
        const u = 1 - Math.pow(1 - t, 3);
        const nx = sx + (tx - sx) * u;
        const ny = sy + (ty - sy) * u + Math.sin((i + t) * 6) * 2;
        c.el.setAttribute('cx', nx);
        c.el.setAttribute('cy', ny);
      } else if (currentInjectMode === 'cursor') {
        // cursor mode: clones follow a virtual cursor direction specified by user (we allow lastCursorPos)
        // if no cursor pos specified, fallback to pathfinding behavior
        if (typeof lastCursorPos !== 'undefined' && lastCursorPos) {
          const sx = 212;
          const sy = 24;
          const tx = lastCursorPos.x;
          const ty = lastCursorPos.y;
          const u = 1 - Math.pow(1 - t, 2); // easeOutQuad
          const nx = sx + (tx - sx) * u;
          const ny = sy + (ty - sy) * u;
          c.el.setAttribute('cx', nx);
          c.el.setAttribute('cy', ny);
        } else {
          // fallback if cursor not set
          const sx = 212;
          const sy = 24;
          const tx = 36;
          const ty = 24;
          const u = 1 - Math.pow(1 - t, 2);
          c.el.setAttribute('cx', sx + (tx - sx) * u);
          c.el.setAttribute('cy', sy + (ty - sy) * u);
        }
      }
    }

    // occasionally print detailed clone telemetry (verbose, not trimmed)
    if (Math.floor(elapsed / 800) !== Math.floor((elapsed - 40) / 800)) {
      appendLine('clone telemetry update t=' + Math.floor(elapsed) + 'ms');
    }

    if (elapsed >= CLONE_DURATION) {
      clearInterval(cloneInterval);
      cloneInterval = null;
      clonesActive = false;
      appendLine('clone sequence complete - 5s elapsed');
      // leave clone circles in place: they stay where animation ended
      appendLine('(clones spawned and active — use inject <mode> to change movement behavior)');
    }
  }, 40); // ~25 FPS
}

/* teleport:
   - requires controlRan true
   - visual: particle moves from T back to user (reverse motion path) once
   - prints detailed progress every ~20% to simulate transfer
*/
function cmd_teleport() {
  if (!controlRan) {
    appendLine('Teleport denied — run control first');
    return;
  }
  appendLine('> Establishing teleport sequence', 'cmd-echo');

  // Create wrapper with reverse path animation (T -> user)
  const twrap = document.createElement('div');
  twrap.className = 'visual-wrap';
  twrap.innerHTML = '' +
    '<svg viewBox="0 0 240 80" xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true">' +
    '  <g transform="translate(12,8) scale(1)">' +
    '    <rect x="0" y="0" width="48" height="32" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>' +
    '  </g>' +
    '  <g transform="translate(112,2) scale(1)">' +
    '    <circle cx="28" cy="28" r="24" fill="#071" stroke="#ff6b6b"/>' +
    '  </g>' +
    '  <g transform="translate(212,12) scale(1)">' +
    '    <rect x="0" y="0" width="24" height="24" rx="4" ry="4" fill="#111" stroke="#ff6b6b"/>' +
    '    <text x="12" y="16" font-size="16" text-anchor="middle" fill="#ff6b6b">T</text>' +
    '  </g>' +
    '  <defs>' +
    '    <path id="motionPath_tele" d="M212,24 C184,36 156,36 128,36 C80,24 36,24 36,24" fill="none" stroke="none"/>' +
    '  </defs>' +
    '  <path d="M212,24 C184,36 156,36 128,36 C80,24 36,24 36,24" stroke="#ff6b6b" stroke-width="1" fill="none" opacity="0.08" stroke-dasharray="6 6"/>' +
    '  <g>' +
    '    <circle r="4" fill="#ff6b6b" opacity="0.95">' +
    '      <animateMotion dur="2.4s" repeatCount="1" rotate="auto" fill="freeze">' +
    '        <mpath xlink:href="#motionPath_tele"/>' +
    '      </animateMotion>' +
    '    </circle>' +
    '  </g>' +
    '</svg>';
  cmdBody.appendChild(twrap);
  cmdBody.scrollTop = cmdBody.scrollHeight;

  // progress printed every ~20%
  let p = 0;
  const increments = [20, 40, 60, 80, 100];
  let idx = 0;
  const pInterval = setInterval(function() {
    p += 20;
    appendLine('establishing teleport progress ' + p + '%');
    idx++;
    if (p >= 100) {
      clearInterval(pInterval);
      appendLine('transfer complete');
      cmdInput.focus();
    }
  }, 520);
}

/* inject <mode>
   - available only after controlRan true
   - modes:
       random      -> clones jitter and roam unpredictably
       pathfinding -> clones move to specific pathfinding target (defaults to left computer)
       cursor      -> clones move toward a cursor position set by clicking inside the last visual SVG
   - this function sets the global currentInjectMode; actual movement is applied by the clone loop
*/
let lastCursorPos = null; // used by cursor mode (updated by user clicks)

function cmd_inject_set(mode) {
  if (!controlRan) {
    appendLine('Inject denied — run control first');
    return;
  }
  if (!mode) {
    appendLine('Specify mode: random pathfinding cursor');
    return;
  }
  mode = mode.trim().toLowerCase();
  if (mode !== 'random' && mode !== 'pathfinding' && mode !== 'cursor') {
    appendLine('Unknown inject mode ' + mode + ' - valid: random, pathfinding, cursor');
    return;
  }
  currentInjectMode = mode;
  appendLine('inject mode set to ' + currentInjectMode);
  appendLine('(if using cursor mode, click inside the last visual to set a cursor target)');
}

/* helper to attach click-to-set-cursor capability to the most recent visual wrap */
function allowCursorClicksOnLatestVisual() {
  // the last visual container appended to cmdBody
  const visuals = cmdBody.querySelectorAll('.visual-wrap');
  if (!visuals || visuals.length === 0) return;
  const latest = visuals[visuals.length - 1];
  if (!latest) return;
  latest.style.cursor = 'crosshair';
  latest.onclick = function(ev) {
    // compute relative position inside SVG if clicked on an SVG element
    // find svg inside latest
    const svg = latest.querySelector('svg');
    if (!svg) return;
    // get bounding rect
    const rect = svg.getBoundingClientRect();
    // Map click coords to viewBox coords (viewBox 0 0 240 80)
    const vbWidth = 240, vbHeight = 80;
    const x = ((ev.clientX - rect.left) / rect.width) * vbWidth;
    const y = ((ev.clientY - rect.top) / rect.height) * vbHeight;
    lastCursorPos = { x: x, y: y };
    appendLine('cursor target set x=' + Math.round(x) + ' y=' + Math.round(y));
  };
}

/* spawn clone verbose wrapper to keep long-form logs (non-truncated) */
function cmd_spawn_clone_verbose() {
  // keep API same as cmd_spawn_clone but with extra logging
  appendLine('spawn clone command received - preparing detailed spawn'); 
  cmd_spawn_clone(); // invoke actual spawn routine
  // after spawn, allow cursor selection by clicking the visual
  setTimeout(function(){
    allowCursorClicksOnLatestVisual();
  }, 120);
}

/* spawn clone entrypoint (calls internal detailed routine) */
function cmd_spawn_clone_entry() {
  cmd_spawn_clone_verbose();
}

/* spawn clone function reference - we've defined above cmd_spawn_clone used by verbose wrapper */

/* spawn clone alias names: spawn clone, clone, spawn */
function handle_spawn_variants(raw) {
  // Accept multiple aliases, call canonical spawn routine
  cmd_spawn_clone_entry();
}

/* spawn clone detailed routine is already defined above */

/* spawn clone done above - continue with unknown commands handling below */

/* ===========================
   Command dispatcher - parse every input string and call appropriate function.
   Preserves full, explicit checks and verbose logging.
   =========================== */
function handleCommand(raw) {
  // Normalize input; allow multi-word commands
  const rawStr = String(raw || '').trim();
  if (rawStr.length === 0) return;
  // Print echo line (all lines red)
  appendLine('> ' + escapeHtml(rawStr), 'cmd-echo');

  // Tokenize - simple split by spaces, but preserve second word for "inject mode"
  const tokens = rawStr.split(/\s+/);
  const cmd = tokens[0].toLowerCase();

  // Map commands to functions with full checks and verbose logs
  if (cmd === 'firewall') {
    cmd_firewall();
    return;
  }

  if (cmd === 'hack') {
    cmd_hack();
    return;
  }

  if (cmd === 'listen') {
    cmd_listen();
    return;
  }

  if (cmd === 'control') {
    cmd_control();
    return;
  }

  // spawn clone variants: 'spawn clone', 'spawn', 'clone'
  if (cmd === 'spawn') {
    // if user wrote 'spawn clone' allow second token 'clone' if provided
    if (tokens.length > 1 && tokens[1].toLowerCase() === 'clone') {
      handle_spawn_variants(rawStr);
    } else {
      // assume spawn clone if no other args
      handle_spawn_variants(rawStr);
    }
    return;
  }
  if (cmd === 'clone') {
    handle_spawn_variants(rawStr);
    return;
  }

  // teleport
  if (cmd === 'teleport') {
    cmd_teleport();
    return;
  }

  // inject modes: command "inject random" OR "inject pathfinding" OR "inject cursor"
  if (cmd === 'inject') {
    if (tokens.length < 2) {
      appendLine('Specify inject mode: random pathfinding cursor');
      return;
    }
    const mode = tokens[1].toLowerCase();
    cmd_inject_set(mode);
    // after setting inject mode, attach click handler for cursor mode visuals
    if (mode === 'cursor') {
      appendLine('(click on the last visual to set cursor target)');
      allowCursorClicksOnLatestVisual();
    }
    return;
  }

  // user may provide 'help' - verbose help listing all commands (long-form)
  if (cmd === 'help') {
    appendLine('Available commands', 'cmd-strong');
    appendLine('- firewall         Engage firewall breaker (must run before hack to have success)');
    appendLine('- hack             Run hack sequence (~5s). If firewall not broken result is ACCESS DENIED');
    appendLine('- listen           Discover target and display visual (run after successful hack)');
    appendLine('- control          Engage control mode (enabled after listen)');
    appendLine('- spawn clone      Spawn multiple clone entities (5s animation). Requires control');
    appendLine('- teleport         Teleport particle from target back to user (requires control)');
    appendLine('- inject <mode>    Set movement injection mode for clones. modes: random pathfinding cursor');
    appendLine('- help             Show this help (verbose)');
    appendLine('Notes: Commands are simulated UI only. No real network actions are performed.');
    return;
  }

  // default unknown command verbose text
  appendLine('Unknown command ' + escapeHtml(rawStr));
}

/* ------------------------
   Wiring input events
   ------------------------ */
cmdInput.addEventListener('keydown', function(e) {
  if (e.key === 'Enter') {
    const val = cmdInput.value;
    cmdInput.value = '';
    if (!mainLoaded) { appendLine('Terminal not ready'); return; }
    handleCommand(val);
  } else if (e.key === 'Escape') {
    hideTerminal();
  }
});

/* Clicking loadBox opens terminal if ready */
loadBox.addEventListener('click', function() {
  if (mainLoaded) showTerminal();
});

/* ------------------------
   Start the loading sequence automatically on page load
   ------------------------ */
startLoading();

/* ------------------------
   Final comment:
   - This script is intentionally verbose and explicit in each block.
   - All terminal UI is simulated and purely client-side.
   - You can modify constants at top (CLONE_COUNT, CLONE_DURATION) to change behavior.
   ------------------------ */
</script>
</body>
</html>
